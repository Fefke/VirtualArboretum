<!doctype html>
<html lang="de">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="icon" href="/favicon.ico" sizes="any">
	<link rel="icon" type="image/png" sizes="32x32" href="images/VA-Logo.png">
	<link rel="icon" type="image/png" sizes="16x16" href="images/VA-Logo.png">

	<title>Virtual Arboretum - Pr√§sentation</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/simple.css" id="theme">

	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		/* Custom Background Gradient */
		.reveal {
			/* width: 300px; */
			/* height: 200px; */
			color: rgb(205, 203, 203);
			/* Gradient mit relativ schmalen √úberg√§ngen */
			background: radial-gradient(ellipse at center,
					#3B1A3F 0%,
					/* Dunkles, warmes Purpur (Start) */
					#45204A 35%,
					/* W√§rmeres Violett (Variation 1) */
					#502A55 70%,
					/* Etwas helleres warmes Violett (Variation 2) */
					#38183D 100%
					/* Dunkles, warmes Purpur (Ende, √§hnlich Start) */
				);

			/* Gradient muss gr√∂√üer sein als das Element, um ihn bewegen zu k√∂nnen */
			background-size: 200% 100%;
			/* Animation anwenden (z.B. 10 Sekunden Dauer) */
			animation: gradient-scroll 23s linear infinite;
		}

		/* Keyframes, die die Hintergrundposition verschieben */
		@keyframes gradient-scroll {
			0% {
				background-position: 0% 50%;
			}

			50% {
				background-position: 100% 50%;
			}

			100% {
				background-position: 0% 50%;
			}
		}

		/* Optional: Ensure links are visible */
		.reveal a {
			color: #add8e6;
			/* Light Blue for links */
		}

		.reveal a:hover {
			color: #f0e68c;
			/* Khaki on hover */
		}

		/* Optional: Anpassungen f√ºr simple.css auf dunklem Hintergrund */
		.reveal h1,
		.reveal h2,
		.reveal h3,
		.reveal h4,
		.reveal h5,
		.reveal h6 {
			color: white;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
			/* Optional: Leichter Schatten f√ºr bessere Lesbarkeit */
		}

		/* Code Snippet Styling */
		.reveal pre code {
			font-size: 0.8em;
			line-height: 1.2em;
			max-height: 70vh;
			/* Maximale H√∂he f√ºr Code-Bl√∂cke */
			overflow-y: auto;
			/* Scrollbar bei Bedarf */
			background-color: rgba(0, 0, 0, 0.3);
			/* Leicht transparenter dunkler Hintergrund f√ºr Code */
			border-radius: 5px;
		}

		.reveal ul,
		.reveal ol {
			font-size: 0.9em;
		}

		.reveal section>ul,
		.reveal section>ol {
			margin-bottom: 15px;
			/* Abstand nach Listen */
		}

		/* Kleinere Schrift f√ºr Dateinamen in Code-Bl√∂cken */
		.code-filename {
			display: block;
			text-align: right;
			font-size: 0.7em;
			color: #ccc;
			margin-bottom: -10px;
			margin-right: 10px;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<section>
				<h1 style="font-size:2.7em;">Virtual Arboretum</h1>

				<img src="images/VA-Logo.png" width="37%" alt="Logo Virtual Arboretum"
					style="display: block; margin: 1em auto 0 auto;">
				<small>
					<p style="margin-top: 2em;"> Name: Blank, Felix / Matrikelnummer: 6011914 / Abgabedatum: 07.05.2025
					</p>
				</small>
			</section>




			<section>
				<section>
					<h2>Einf√ºhrung</h2>
				</section>
				<section>
					<h3>√úbersicht √ºber die Applikation</h3>
					<aside class="notes">
						Hier geben wir einen kurzen √úberblick dar√ºber, was die Applikation "VirtualArboretum" macht, wie
						sie funktioniert und welches Problem sie zu l√∂sen versucht.
					</aside>
				</section>
				<section>
					<h4>Was macht die Applikation?</h4>
					<ul>
						<li>Pflanzen (Daten aller Art) einlagern</li>
						<li>Lebenszyklus von Pflanzen begleiten</li>
						<li>Strukturierte Ausgabe von Pflanzendaten</li>
						<li>Lebenszyklus: Einlagern, Inkubieren, Reseeden, Auslesen, Vergehen</li>
					</ul>
					<aside class="notes">
						Die Kernfunktion ist das Management von digitalen "Pflanzen" und deren Daten √ºber ihren gesamten
						Lebenszyklus hinweg. Dieser Zyklus beinhaltet verschiedene Phasen von der Erstellung bis zur
						Archivierung.
					</aside>
				</section>
				<section>
					<h4>Wie funktioniert sie?</h4>
					<ul>
						<li>Interaktion √ºber CLI (Command Line Interface)</li>
						<li><em>Aktuell: Nur √ºber Tests der Use-Cases</em></li>
					</ul>
					<aside class="notes">
						Die Interaktion mit der Applikation ist prim√§r f√ºr ein Command Line Interface vorgesehen.
						Derzeit ist die Bedienung jedoch haupts√§chlich durch das Ausf√ºhren von Testf√§llen der
						definierten Anwendungsf√§lle m√∂glich.
					</aside>
				</section>
				<section>
					<h4>Welches Problem l√∂st sie/welchen Zweck hat sie?</h4>
					<ul>
						<li>Kontrolliertes Wachstum lokaler Verzeichnisstrukturen</li>
						<li>Attributbasierte Zusammenh√§nge statt hierarchischer Baumstruktur</li>
						<li><strong>Nat√ºrliche Verbindungen</strong> zwischen Belangen</li>
						<li>Umgehung von L√§ngenlimitierungen bei Dateinamen (255 Byte)</li>
						<li>Strukturierte Assoziation √ºber symbolische Links (Hyphae/Attribute)</li>
						<li>Implizite Sichten auf Dateien (Pflanzen)</li>
						<li>Nah am Dateisystem, minimale Abh√§ngigkeiten von individuellen Formaten</li>
					</ul>
					<aside class="notes">
						Das VirtualArboretum zielt darauf ab, die Organisation von Dateien zu revolutionieren, indem es
						von starren hierarchischen Strukturen zu einem flexiblen, attributbasierten System √ºbergeht.
						Dies erm√∂glicht es, nat√ºrliche Beziehungen zwischen Daten herzustellen und Beschr√§nkungen
						traditioneller Dateisysteme, wie die L√§ngenbegrenzung von Dateinamen, zu umgehen. Durch die
						Verwendung von symbolischen Links, die als "Hyphae" (Attribute) fungieren, k√∂nnen verschiedene
						Sichten auf die "Pflanzen" (Dateien) erzeugt werden, ohne dass propriet√§re Formate ben√∂tigt
						werden, wie es bei vielen Tagging-Engines der Fall ist.
					</aside>
				</section>
				<section>
					<h3>Starten der Applikation</h3>
					<aside class="notes">
						Wie wird die Applikation gestartet und welche Voraussetzungen sind n√∂tig?
					</aside>
				</section>
				<section>
					<h4>Wie startet man die Applikation?</h4>
					<ul>
						<li>Aktuell: Nur √ºber Tests von Use-Cases (Pr√§sentations-Schicht fehlt)</li>
						<li>Ziel-Interaktionen:
							<ol>
								<li>CLI: Direkte, lokale Interaktion im Terminal.</li>
								<li>REST API: Via <code>va web</code> o.√§.</li>
								<li><em>Dateisystem-Watcher (√§hnlich git) oder Aufsatteln auf Git.</em></li>
							</ol>
						</li>
					</ul>
					<aside class="notes">
						Momentan ist der Start der Applikation auf das Ausf√ºhren von Tests beschr√§nkt, da die oberste
						Pr√§sentationsschicht noch nicht implementiert ist. Zuk√ºnftig soll die Applikation √ºber ein CLI,
						eine REST API oder sogar √ºber einen Dateisystem-Watcher, der √Ñnderungen automatisch erfasst,
						gestartet werden k√∂nnen.
					</aside>
				</section>
				<section>
					<h4>Was f√ºr Voraussetzungen werden ben√∂tigt?</h4>
					<ul>
						<li>Nicht zwingend (Single Executable m√∂glich)</li>
						<li><em>Ideal: .NET Runtime vorhanden (vermeidet Auslieferung von Binaries)</em></li>
						<li>Optional: Betrieb in Containern</li>
						<li><em>Empfehlenswert: Container-Runtime f√ºr Inkubation mit Third-Party-Skripten
								(Kontextabsteckung)</em></li>
					</ul>
					<aside class="notes">
						Grunds√§tzlich kann die Applikation als einzelne ausf√ºhrbare Datei ausgeliefert werden, wodurch
						keine speziellen Voraussetzungen zwingend erforderlich sind. Dennoch ist eine vorhandene .NET
						Runtime ideal, um die Gr√∂√üe der Auslieferung zu reduzieren. F√ºr bestimmte Anwendungsf√§lle, wie
						die Inkubation mit Skripten von Drittanbietern, wird der Einsatz von Containern zur
						Kontextabgrenzung empfohlen.
					</aside>
				</section>
				<section>
					<h4>Demonstration des Vorgangs und 1 ‚Äì 2 Use Cases</h4>
					<ul>
						<li>[x] Pflanzen mit assoziierenden Hyphae einlagern.</li>
						<li>[x] Pflanzen nach Hyphae untersuchen und auswerten.</li>
					</ul>
					<aside class="notes">
						Zwei zentrale Anwendungsf√§lle sind das Einlagern von Pflanzen mit zugeh√∂rigen Attributen
						(Hyphae) und das sp√§tere Durchsuchen und Auswerten dieser Pflanzen basierend auf ihren Hyphae.
					</aside>
				</section>
				<section>
					<h3>Technischer √úberblick</h3>
					<aside class="notes">
						Ein Blick auf die verwendeten Technologien.
					</aside>
				</section>
				<section>
					<h4>Nennung und Erl√§uterung der Technologien</h4>
					<ul>
						<li><strong>C# .NET Core 9</strong> (aktuellste LTS)
							<ul>
								<li><em>Prim√§r aus Eigeninteresse zur Vertiefung der Sprachkenntnisse.</em></li>
							</ul>
						</li>
						<li>Ausschlie√ülich mit <strong>System-Bibliotheken</strong> (Projektvorgabe)</li>
						<li><strong>LINQ</strong> (aus .NET Core)
							<ul>
								<li>Kompakte Daten-Transformationen.</li>
								<li><em>Einfache Parallelisierung mit PLINQ (bei `System.Collections.Concurrent`).</em>
								</li>
								<li><em>√Ñquivalent zur Stream API ab Java 8.</em></li>
							</ul>
						</li>
						<li><strong>MSTest</strong>: Testing-Framework f√ºr automatische (Unit-)Tests.</li>
						<li><strong>SonarQube</strong> & VS-Erweiterung
							<ul>
								<li><em>F√ºr tiefere Einblicke in Code-Qualit√§t und gezielte Verbesserung.</em></li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Die Applikation basiert auf C# .NET Core 9 und verwendet ausschlie√ülich System-Bibliotheken, wie
						es die Projektvorgaben erfordern. LINQ wird f√ºr Datenmanipulationen eingesetzt, MSTest f√ºr die
						Qualit√§tssicherung durch Unit-Tests und SonarQube zur Analyse und Verbesserung der
						Code-Qualit√§t. Die Wahl von C# erfolgte auch aus pers√∂nlichem Interesse an der Sprache.
					</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>Clean Architecture</h2>
				</section>
				<section>
					<h3>Was ist Clean Architecture?</h3>
					<ul>
						<li>Saubere Grenzen zwischen Belangen/Kontexten.</li>
						<li>Dom√§ne vs. Anwendung.</li>
						<li>Anwendung vs. Anwendende.</li>
						<li><em>Anwendung vs. Angewendetes.</em></li>
						<li>Nur Vertrags√ºbergabe (serialisierte Entit√§ten) an Grenzen (MVP).</li>
						<li>Verweis auf externes Bild (nicht darstellbar, siehe Original-Dokument).</li>
					</ul>
					<aside class="notes">
						Clean Architecture ist ein Software-Architekturprinzip, das auf der Trennung von Belangen durch
						klar definierte Grenzen basiert. Die Dom√§nenlogik ist das Herzst√ºck und unabh√§ngig von √§u√üeren
						Schichten wie der Benutzeroberfl√§che oder der Datenbank. An den Grenzen zwischen den Schichten
						erfolgt die Kommunikation idealerweise nur √ºber einfache Datenstrukturen (DTOs) oder Vertr√§ge.
						Das Bild `![[Studere üéì/6. Semester üéâ/üèóÔ∏è Advanced Software Engineering/{01}
						Programmentwurf/IMG_0562.jpg]]` kann hier nicht direkt eingebettet werden.
					</aside>
				</section>
				<section>
					<h3>Analyse der Dependency Rule</h3>
				</section>
				<section>
					<h4>‚úÖ Dependency Rule: Abh√§ngigkeiten nur nach innen.</h4>
					<ul>
						<li><code>PlacePlant</code> UseCase: Verwendet DTOs seiner Schicht, Mapping auf Dom√§nentypen via
							<code>PlantMapper</code>.
						</li>
						<li><em><code>GardenMapper</code> in <code>InMemoryGardenRepository</code>: De-Serialisierung,
								keine Verletzung (√§u√üere Schicht nutzt innere Klassen).</em></li>
						<li><em>Analyse via UML von <code>PlantMapper</code> (sp√§ter).</em></li>
					</ul>
					<aside class="notes">
						Die Dependency Rule besagt, dass Abh√§ngigkeiten immer nur von √§u√üeren zu inneren Schichten
						zeigen d√ºrfen. Ein positives Beispiel ist der `PlacePlant` UseCase, der korrekterweise Data
						Transfer Objects (DTOs) aus seiner eigenen Schicht verwendet und diese √ºber einen `PlantMapper`
						auf Typen der Dom√§nenschicht abbildet und umgekehrt. Auch die Verwendung des `GardenMappers` im
						`InMemoryGardenRepository` zur De-Serialisierung verletzt die Regel nicht, da √§u√üere Schichten
						(Infrastruktur) Klassen aus inneren Schichten (Anwendung, Dom√§ne) verwenden d√ºrfen.
					</aside>
				</section>
				<section>
					<h4>‚ö†Ô∏è Dependency Rule verletzt: Abh√§ngigkeit nach au√üen.</h4>
					<ul>
						<li><code>CellType</code> (Dom√§nen-Modell):
							<ul>
								<li>Verwendet <code>Console.Error.WriteLine</code> zur Signalisierung nicht
									unterst√ºtzter MediaTypes.</li>
								<li>Dom√§nen-Modell sollte keine direkten Konsolenausgaben machen.</li>
								<li>Richtig: Logging Singleton via Repository in Log-Aggregator/Datei.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Eine Verletzung der Dependency Rule liegt im Dom√§nen-Modell bei der Klasse `CellType` vor. Diese
						schreibt Fehlermeldungen direkt auf `Console.Error`, was eine Abh√§ngigkeit zur Infrastruktur
						(Konsole) darstellt. Eine saubere L√∂sung w√§re die Verwendung eines Logging-Mechanismus, der √ºber
						ein Repository-Interface angebunden ist und von der Infrastrukturschicht implementiert wird.
					</aside>
				</section>
				<section>
					<h3>Analyse der Schichten</h3>
					<p>Jeweils 1 Klasse zu 2 unterschiedlichen Schichten.</p>
				</section>
				<section>
					<h4>Entit√§t in Dom√§ne: <code>Plant</code></h4>
					<ul>
						<li>Identifiziert Zusammenschluss aus <code>Cell</code>-Instanzen.</li>
						<li>Ordnet Cells zwei Abstraktions-Mustern zu:
							<ul>
								<li>Klassisch-hierarchisch: <code>.Name</code> HyphaStrain.</li>
								<li>Vielzahl an <code>AssociatedHyphae</code>-Strains.</li>
							</ul>
						</li>
						<li>Zusammenschluss aus Werteobjekten & anderen Entit√§ten -> Entit√§t.</li>
						<li>Auch als Aggregate Root (wg. 1:N Cells Relation, Vielf√§ltigkeit, Zentralit√§t) einordenbar.
						</li>
					</ul>
					<aside class="notes">
						Die `Plant`-Klasse ist eine zentrale Entit√§t im Dom√§nenmodell. Sie repr√§sentiert eine Pflanze
						und b√ºndelt Informationen in Form von `Cell`-Instanzen. `Plant` nutzt sowohl ein hierarchisches
						Modell (√ºber den `.Name` HyphaStrain) als auch ein attributbasiertes Modell (√ºber
						`AssociatedHyphae`). Aufgrund ihrer Rolle als Sammelpunkt f√ºr andere Werteobjekte und Entit√§ten
						und ihrer zentralen Bedeutung k√∂nnte sie auch als Aggregate Root betrachtet werden.
					</aside>
				</section>
				<section>
					<h4>UseCase in Anwendung: <code>PlacePlant</code></h4>
					<ul>
						<li>Aufgabe: Logik zum Hinzuf√ºgen einer Pflanze in einen Garten.</li>
						<li>Einordnung: Anwendungsschicht.
							<ul>
								<li>Orchestriert Dom√§nenobjekte (<code>Plant</code>, <code>Garden</code>).</li>
								<li>Nutzt Repositories f√ºr Persistenz.</li>
								<li>Verwendet DTOs f√ºr Kommunikation nach au√üen.</li>
								<li>Implementiert spezifischen Anwendungsfall.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Der `PlacePlant` UseCase geh√∂rt zur Anwendungsschicht. Seine Aufgabe ist es, die Gesch√§ftslogik
						f√ºr das Platzieren einer Pflanze in einem Garten zu kapseln. Er interagiert mit Dom√§nenobjekten,
						verwendet Repository-Interfaces f√ºr den Datenzugriff und kommuniziert √ºber DTOs mit √§u√üeren
						Schichten. Dies ist ein typisches Beispiel f√ºr eine Klasse in der Anwendungsschicht der Clean
						Architecture.
					</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>SOLID</h2>
				</section>
				<section>
					<h3>Analyse Single Responsibility Principle (SRP)</h3>
				</section>
				<section>
					<h4>Positive Beispiel-Klasse f√ºr SRP: <code>Fingerprint</code></h4>
					<ul>
						<li>Werteobjekt: Nur eine Aufgabe.</li>
						<li>Wrappt eine GUID v7.</li>
						<li>Bietet Methode zum Zugriff auf Unix-Zeitstempel der GUID (Chronologie).</li>
					</ul>
					<aside class="notes">
						Die Klasse `Fingerprint` ist ein gutes Beispiel f√ºr das Single Responsibility Principle. Als
						Werteobjekt hat sie die klar definierte Aufgabe, eine GUID v7 zu kapseln und eine Methode zur
						Extraktion des Zeitstempels bereitzustellen.
					</aside>
				</section>
				<section>
					<h4>Negative Beispiel-Klasse f√ºr SRP: <code>Mycelium</code></h4>
					<ul>
						<li>H√§lt Hyphal-Plexus (Hyphen-Netzwerk).</li>
						<li>H√§lt Assoziationen (Strains-Plants, Strains-Gardens).</li>
						<li>Ist "Grammatik" der Hyphae-Sprache.</li>
						<li>Ideal: Auslagerung der Verantwortung.
							<ul>
								<li>Lokale Plexus in <code>Garden</code>-Instanzen.</li>
								<li><code>MyceliumAssociations</code>-Instanz f√ºr Aufl√∂sung.</li>
							</ul>
						</li>
						<li><em>Weitere Beispiele: <code>MyceliumQueryService</code>,
								<code>HyphaeSerializationService</code>.</em></li>
					</ul>
					<aside class="notes">
						Die Klasse `Mycelium` verletzt tendenziell das SRP, da sie mehrere Verantwortlichkeiten b√ºndelt:
						das Halten des Hyphen-Netzwerks, die Verwaltung von Assoziationen und die Definition der
						"Grammatik" der Hyphae-Sprache. Eine bessere Aufteilung k√∂nnte durch die Einf√ºhrung
						spezialisierter Klassen wie `MyceliumAssociations` oder durch die Verlagerung von
						Verantwortlichkeiten in `Garden`-Instanzen erreicht werden.
					</aside>
				</section>
				<section>
					<h3>Analyse Open Closed Principle (OCP)</h3>
				</section>
				<section>
					<h4>Positives Beispiel f√ºr OCP: <code>Hypha</code></h4>
					<ul>
						<li>Basis-Klasse <code>Hypha</code>: Interne "Erweiterung" eines HyphaStrains.</li>
						<li>Spezielle Implementierungen (<code>HyphaApex</code>, <code>DecimalHypha</code>) erweitern
							Basis-Klasse.</li>
						<li>Keine √Ñnderungen an Basis-Klasse n√∂tig.</li>
					</ul>
					<aside class="notes">
						Die `Hypha`-Klassenhierarchie ist ein gutes Beispiel f√ºr das Open/Closed Principle. Die
						Basisklasse `Hypha` ist offen f√ºr Erweiterungen durch spezialisierte Subklassen wie `HyphaApex`
						oder `DecimalHypha`, muss aber f√ºr diese Erweiterungen selbst nicht modifiziert werden.
					</aside>
				</section>
				<section>
					<h4>OCP: Hypha Klassendiagramm - Einleitung</h4>
					<p>Das folgende Diagramm illustriert die Struktur der <code>Hypha</code>-Basisklasse und ihrer
						Erweiterungen, was das Open-Closed-Prinzip verdeutlicht. Neue Hypha-Typen k√∂nnen hinzugef√ºgt
						werden, ohne die <code>Hypha</code>-Basisklasse zu √§ndern.</p>
				</section>
				<section>
					<h4>OCP: Hypha Klassendiagramm</h4>
					<div class="mermaid">
						classDiagram
						%%! Basisklasse f√ºr alle Hypha-Typen im Dom√§nenmodell.
						class Hypha {
						+HyphaKey Key
						+DoesExtend() bool
						+NextExtension() Hypha?
						+ToString() string
						+Equals(object other) bool
						+GetHashCode() int
						}

						%%! Spezialisierte Hypha, die wie ein einfacher Tag funktioniert.
						%%! Der 'Value' der Basisklasse ist hier gleich dem 'Key'.
						class HyphaApex {
						+ToString() string
						}

						%%! Spezialisierte Hypha, die einen Dezimalwert repr√§sentiert.
						%%! Der Dezimalwert wird im 'Value' der Basisklasse gespeichert.
						class DecimalHypha {
						+AsDecimal() Decimal
						}

						%%! Stellt den Schl√ºssel (Namensteil) einer Hypha dar.
						class HyphaKey {
						+string Value
						+ToString() string
						}

						%%! Vererbungsbeziehungen von der Basisklasse Hypha.
						Hypha <|-- HyphaApex Hypha <|-- DecimalHypha %%! Assoziation: Jede Hypha hat genau einen
							HyphaKey. Hypha "1" *-- "1" HyphaKey : hat </div>
							<aside class="notes">
								Dieses UML-Diagramm zeigt die `Hypha`-Basisklasse und wie `HyphaApex` sowie
								`DecimalHypha` von ihr erben. Jede `Hypha` ist mit einem `HyphaKey` assoziiert. Dies
								demonstriert, wie das System durch neue Hypha-Typen erweitert werden kann, ohne die
								Kernfunktionalit√§t von `Hypha` zu ver√§ndern.
							</aside>
				</section>
				<section>
					<h4>Negatives Beispiel f√ºr OCP: <code>ParseHyphaType</code> in
						<code>HyphaeSerializationService</code>
					</h4>
					<ul>
						<li>Parsing-Vorgang in dieser Methode.</li>
						<li>Neue Typen (<code>DateTimeHypha</code>, <code>IpAddressHypa</code>) erfordern √Ñnderung der
							Methode.</li>
						<li>Ideal:
							<ul>
								<li>Zwingende Implementierung von <code>IParsable</code> bei Erweiterung.</li>
								<li><code>HyphaeSerializationService</code> nutzt Strategie-Pattern (z.B.
									<code>ParseHyphaType</code>-Methode).
								</li>
								<li>Neue Implementierungen registrieren sich zentral.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Die Methode `ParseHyphaType` im `HyphaeSerializationService` verletzt das OCP. Wenn neue
						Hypha-Typen wie `DateTimeHypha` eingef√ºhrt werden, muss diese Methode modifiziert werden, um das
						Parsing dieser neuen Typen zu unterst√ºtzen. Eine bessere L√∂sung w√§re die Verwendung des
						Strategie-Patterns oder die Forderung nach einer `IParsable`-Implementierung f√ºr neue Typen, die
						sich dann zentral registrieren.
					</aside>
				</section>
				<section>
					<h4>OCP Verletzung: HyphaeSerializationService - Einleitung</h4>
					<p>Das Diagramm zeigt, wie die Klasse <code>HyphaeSerializationService</code> bei der Einf√ºhrung
						neuer Hypha-Typen (z.B. <code>DateTimeHypha</code>) modifiziert werden muss. Dies widerspricht
						dem Open-Closed-Prinzip, da die Klasse nicht f√ºr Erweiterungen geschlossen ist.</p>
				</section>
				<section>
					<h4>OCP Verletzung: HyphaeSerializationService</h4>
					<div class="mermaid">
						classDiagram
						direction LR
						%%! Das Service, das Hyphae parst
						class HyphaeSerializationService {
						+ParseHyphaType(string hyphaKey, string hyphaValue) Hypha
						%%! --- OCP Verletzungsbereich ---
						%%! Diese Methode muss ge√§ndert werden, um neue Typen
						%%! wie DateTimeHypha zu unterst√ºtzen.
						%%! interner Code (vereinfacht):
						%%! if (decimal.TryParse(..)) { return new DecimalHypha(..) }
						%%! else if (DateTime.TryParse(..)) { %%! <-- NEUER CODE n√∂tig f√ºr DateTimeHypha %%! return new
							DateTimeHypha(..) %%! <-- NEUER CODE n√∂tig f√ºr DateTimeHypha %%! } else { return new
							Hypha(.., HyphaApex(..)) } } %%! Basis-Hypha (oder Interface) class Hypha { <<abstract>>
							+HyphaKey Key
							+object Value
							}

							%%! Bestehende, spezifische Hypha-Implementierungen
							class DecimalHypha
							class HyphaApex

							%%! Neuer, hinzuzuf√ºgender Hypha-Typ
							class DateTimeHypha {
							+DateTime AsDateTime()
							}

							%%! Vererbungsbeziehungen
							Hypha <|-- DecimalHypha Hypha <|-- HyphaApex Hypha <|-- DateTimeHypha %%! Abh√§ngigkeiten:
								Service erstellt/verwendet die Hypha-Typen HyphaeSerializationService ..> DecimalHypha :
								creates/uses
								HyphaeSerializationService ..> HyphaApex : creates/uses
								HyphaeSerializationService ..> DateTimeHypha : creates/uses (nach Modifikation!)
					</div>
					<aside class="notes">
						Dieses UML-Diagramm illustriert die Verletzung des OCP durch `HyphaeSerializationService`. Die
						Einf√ºhrung eines neuen Typs wie `DateTimeHypha` erfordert eine √Ñnderung in der
						`ParseHyphaType`-Methode, anstatt das System durch Hinzuf√ºgen neuer, in sich geschlossener
						Komponenten zu erweitern.
					</aside>
				</section>
				<section>
					<h3>Analyse Liskov Substitution / Interface Segregation / Dependency Inversion</h3>
				</section>
				<section>
					<h4>Positives Beispiel f√ºr Dependency Inversion (DIP)</h4>
					<ul>
						<li>Use-Cases <code>PlacePlant</code> und <code>RetrievePlant</code>.</li>
						<li>Verwenden ausschlie√ülich <code>IRepository</code> Interfaces (Clean Architecture).</li>
						<li>Abh√§ngigkeit von Abstraktionen, nicht von konkreten Implementierungen.</li>
					</ul>
					<aside class="notes">
						Die Use Cases `PlacePlant` und `RetrievePlant` demonstrieren das Dependency Inversion Principle.
						Sie h√§ngen von Abstraktionen (`IRepository`-Interfaces) ab, nicht von konkreten
						Implementierungen der Repositories. Die konkreten Implementierungen werden zur Laufzeit
						bereitgestellt (z.B. per Dependency Injection).
					</aside>
				</section>
				<section>
					<h4>Negatives Beispiel f√ºr Interface Segregation (ISP)</h4>
					<ul>
						<li><code>IRepository&lt;T&gt;</code>: Potenziell zu viele Abfragemethoden.</li>
						<li>Beispiel: <code>ICellRepository</code> erbt Methoden, die f√ºr Zellen uneindeutig sein
							k√∂nnten (z.B. <code>GetByPrimaryHyphaeAsync</code>, wenn <code>OrganellLocation</code>
							anders angesprochen wird).</li>
						<li>L√∂sung:
							<ul>
								<li>Aufsplitten der Repository-Zugriffe.</li>
								<li>Ggf. Trennung nach Lese-/Schreib-Zugriffen (CQRS-√§hnlich).</li>
								<li>√úberdenken der generischen Natur des Interfaces.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Das generische Interface `IRepository<T>` k√∂nnte das Interface Segregation Principle verletzen,
							wenn es zu viele Methoden enth√§lt, die nicht f√ºr alle Implementierungen relevant sind. Wenn
							beispielsweise ein `ICellRepository` alle Methoden von `IRepository<Cell>` erbt, k√∂nnten
								Methoden wie `GetByPrimaryHyphaeAsync` f√ºr Zellen keinen klaren Sinn ergeben, falls die
								prim√§re Identifikation anders erfolgt. Eine L√∂sung w√§re, spezifischere Interfaces zu
								definieren oder Lese- und Schreiboperationen zu trennen.
					</aside>
				</section>
				<section>
					<h4>ISP Verletzung & DIP Illustration: Repository-Struktur - Einleitung</h4>
					<p>Das folgende Diagramm zeigt die Struktur der Repository-Interfaces und -Implementierungen. Es
						illustriert das Dependency Inversion Principle durch die Verwendung von Interfaces durch die Use
						Cases und deutet auf eine m√∂gliche Verletzung des Interface Segregation Principle durch das
						generische <code>IRepository&lt;T&gt;</code> hin.</p>
				</section>
				<section>
					<h4>ISP Verletzung & DIP Illustration: Repository-Struktur</h4>
					<div class="mermaid">
						classDiagram
						%% Base Repository Interface
						class IRepository~T~ {
						<<interface>>
							%% Definiert allgemeine Repository-Operationen
							+GetByFingerprintAsync(Fingerprint id) Task~T?~
							+GetByPrimaryHyphaeAsync(HyphaeStrain strain) Task~T?~
							+AddAsync(T candidate) Task
							+UpdateAsync(T candidate) Task
							}

							%% Specific Repository Interfaces
							class IArboretumRepository {
							<<interface>>
								%% Verwaltet das Arboretum-Aggregat
								+Open() Arboretum
								+Close() Boolean
								}

								class ICellRepository {
								<<interface>>
									%% Erbt von IRepository<Cell>
										}

										class IGardenRepository {
										<<interface>>
											%% Erbt von IRepository<Garden>
												}

												%% class IMyceliumRepository {
												%% <<interface>>
													%% %% Erbt von IRepository<Mycelium>
														%% %% Hinweis: Keine InMemory-Implementierung in den
														bereitgestellten Dateien gefunden
														%% }

														class IPlantRepository {
														<<interface>>
															%% Erbt von IRepository<Plant>
																}

																%% Interface Inheritance/Realization from IRepository<T>
																	IRepository~Cell~ <|-- ICellRepository
																		IRepository~Garden~ <|-- IGardenRepository %%
																		IRepository~Mycelium~ <|-- IMyceliumRepository
																		IRepository~Plant~ <|-- IPlantRepository %%
																		InMemory Implementations class
																		InMemoryArboretumRepository { %% Implementiert
																		IArboretumRepository }
																		InMemoryArboretumRepository ..|>
																		IArboretumRepository

																		class InMemoryCellRepository {
																		%% Implementiert ICellRepository
																		}

																		InMemoryCellRepository ..|> ICellRepository

																		class InMemoryGardenRepository {
																		%% Implementiert IGardenRepository
																		}
																		InMemoryGardenRepository ..|> IGardenRepository

																		class InMemoryPlantRepository {
																		%% Implementiert IPlantRepository
																		}

																		InMemoryPlantRepository ..|> IPlantRepository

																		%% Use Cases and Services
																		class PlacePlant {
																		%% Use Case zum Platzieren einer Pflanze
																		}

																		class RetrievePlants {
																		%% Use Case zum Abrufen von Pflanzen
																		}
																		class MyceliumQueryService {
																		%% Service zur Abfrage des Myzeliums,
																		unterst√ºtzt RetrievePlants
																		}

																		%% Dependencies from Use Cases/Services to
																		Repository Interfaces
																		%% Zeigt, welche Use Cases/Services welche
																		Repository-Schnittstellen verwenden
																		PlacePlant --> IArboretumRepository
																		PlacePlant --> IGardenRepository
																		PlacePlant --> IPlantRepository

																		RetrievePlants --> IArboretumRepository
																		RetrievePlants --> IPlantRepository

																		MyceliumQueryService --> IArboretumRepository
																		MyceliumQueryService --> IPlantRepository
					</div>
					<aside class="notes">
						Dieses UML-Diagramm visualisiert die Repository-Struktur. Use Cases wie `PlacePlant` und
						`RetrievePlants` h√§ngen von `IRepository`-Interfaces ab (DIP). Die
						`InMemory...Repository`-Klassen implementieren diese Interfaces. Das breite `IRepository<T>
							`-Interface k√∂nnte jedoch das ISP verletzen, da nicht alle abgeleiteten Interfaces alle
							geerbten Methoden ben√∂tigen oder sinnvoll nutzen k√∂nnen.
					</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>Weitere Prinzipien</h2>
				</section>
				<section>
					<h3>General Responsibility Assignment Software Patterns (GRASP)</h3>
					<ul>
						<li>Regelwerk f√ºr:
							<ul>
								<li>Wartbarkeit</li>
								<li>Wiederverwendbarkeit</li>
								<li>Verst√§ndlichkeit</li>
							</ul>
						</li>
						<li>Ziele:
							<ul>
								<li>Geringe Kopplung (Klassenunabh√§ngigkeit)</li>
								<li>Hohe Koh√§sion (fokussierte Verantwortung einer Klasse)</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						GRASP sind eine Reihe von Prinzipien zur Zuweisung von Verantwortlichkeiten in
						objektorientiertem Design. Ihr Ziel ist es, Software zu schaffen, die leichter zu warten,
						wiederzuverwenden und zu verstehen ist, indem eine geringe Kopplung zwischen Klassen und eine
						hohe Koh√§sion innerhalb der Klassen gef√∂rdert wird.
					</aside>
				</section>
				<section>
					<h3>Analyse GRASP: Geringe Kopplung</h3>
					<ul>
						<li><code>GardenMapper</code>: L√∂st Kopplung zur Pr√§sentations-Schicht.</li>
						<li>Wandelt Dom√§nen-interne <code>Garden</code>-Instanzen zu/aus DTOs.</li>
						<li>Vermeidet direktes <code>IParsable</code> auf <code>Garden</code>-Dom√§nenobjekt.</li>
						<li>Statische Methoden von <code>GardenMapper</code> (<code>IntoDto</code>,
							<code>IntoGarden</code>) nur von Use-Cases, Services, Infrastruktur
							(<code>InMemoryGardenRepository</code>) genutzt.
						</li>
						<li>Beschreiben klar Konvertierungsrichtungen.</li>
					</ul>
					<aside class="notes">
						Der `GardenMapper` ist ein Beispiel f√ºr geringe Kopplung. Er entkoppelt die Dom√§nenschicht von
						der Pr√§sentationsschicht (oder anderen √§u√üeren Schichten), indem er f√ºr die Konvertierung
						zwischen `Garden`-Dom√§nenobjekten und `GardenDto`-Daten√ºbertragungsobjekten zust√§ndig ist.
						Dadurch muss das `Garden`-Objekt selbst keine Kenntnis von DTOs oder Serialisierungsdetails
						haben. Die klar definierten, statischen Methoden des Mappers werden gezielt von den Schichten
						verwendet, die diese Konvertierung ben√∂tigen.
					</aside>
				</section>
				<section>
					<h3>Analyse GRASP: Polymorphismus</h3>
					<ul>
						<li>Positives Beispiel: <code>IRepository&lt;&gt;</code> Interfaces.</li>
						<li>Gemeinsame Signaturen, Abbildung auf spezielle Interfaces f√ºr Dom√§nen-Modelle.</li>
						<li>Implementierung in Pr√§sentations-Schicht durch <code>InMemory...Repository</code>.</li>
					</ul>
					<aside class="notes">
						Die Verwendung der `IRepository<>`-Interfaces ist ein Beispiel f√ºr Polymorphismus im Sinne von
							GRASP. Use Cases arbeiten mit dem allgemeinen Interface-Typ, w√§hrend zur Laufzeit
							spezifische Implementierungen (wie die `InMemory...Repositories`) verwendet werden. Dies
							erm√∂glicht Flexibilit√§t und Austauschbarkeit der Datenzugriffsschicht.
					</aside>
				</section>
				<section>
					<h3>DRY (Don't Repeat Yourself)</h3>
				</section>
				<section>
					<h4>Beispiel: <code>HyphaHierarchy</code> Refactoring</h4>
					<ul>
						<li><strong>Vorher (<code>Aggregate</code>)</strong>: Nur <code>HyphaKey</code> und finalen
							<code>Value</code> als String in <code>ImmutableArray&lt;&gt;</code> aggregieren.
						</li>
						<li><strong>Nachher (<code>AggregateHyphae</code> / <code>AggregateHyphaeKeys</code>)</strong>:
							<ul>
								<li>Zuerst gesamte Hypha flach machen (<code>AggregateHyphae</code>).</li>
								<li>Dann <code>HyphaKey</code> extrahieren (<code>AggregateHyphaeKeys</code>).</li>
								<li>Grund: Aggregation ganzer Hyphae in <code>HyphaeStrain</code> wurde ben√∂tigt.</li>
							</ul>
						</li>
						<li>Commit: <code>69467663f...</code></li>
					</ul>
					<aside class="notes">
						Ein Refactoring in der `HyphaHierarchy`-Klasse demonstriert das DRY-Prinzip. Urspr√ºnglich gab es
						eine Methode, die direkt `HyphaKey`-Objekte aggregierte. Da jedoch eine Aggregation der gesamten
						`Hypha`-Objekte an anderer Stelle ben√∂tigt wurde, wurde die Logik aufgeteilt: Eine Methode
						aggregiert nun die Hyphae selbst, und eine zweite Methode nutzt diese, um daraus die Keys zu
						extrahieren. Dadurch wird die Logik zur Aggregation der Hyphae nicht dupliziert.
						Achtung, die Code-Duplikation wurde nicht direkt commited, sondern direkt bereinigt.
					</aside>
				</section>
				<section>
					<h4>DRY: <code>HyphaHierarchy</code> - Vorher</h4>
					<pre><code class="csharp" data-trim data-noescape>
public static ImmutableArray&lt;HyphaKey&gt; Aggregate(Hypha root) {
    return [.. AggregateSubHyphae(root, 1).Item1];
}

private static (HyphaKey[], ushort) AggregateSubHyphae(
Hypha label, ushort depth = 0
){
    if (label.DoesExtend()) {
         var (list, index) = AggregateSubHyphae(
             label.NextExtension()!,
             ++depth);
        list[index] = label.Key;
        return (list, --index);
    }
    // recursion basis.
    HyphaKey[] aggregate = new HyphaKey[depth];
    depth -= 1;
    aggregate[depth] = label.Key;
    depth -= 1;
    return (aggregate, depth);
}
                    </code></pre>
				</section>
				<section>
					<h4>DRY: <code>HyphaHierarchy</code> - Nachher</h4>
					<pre><code class="csharp" data-trim data-noescape>
private static (Hypha[], ushort) AggregateSubHyphae(Hypha hypha, ushort depth = 0) {
    if (hypha.DoesExtend()) {
        var (list, index) = AggregateSubHyphae(
            hypha.NextExtension()!,
            ++depth
        );
        list[index] = hypha;
        return (list, --index);
    }
    // recursion basis.
    Hypha[] aggregate = new Hypha[depth];
    depth -= 1;
    aggregate[depth] = hypha;
    depth -= 1;
    return (aggregate, depth);
}

public static ImmutableArray&lt;Hypha&gt; AggregateHyphae(Hypha root) {
    return [.. AggregateSubHyphae(root, 1).Item1];
}

public static ImmutableArray&lt;HyphaKey&gt; AggregateHyphaeKeys(Hypha root) {
    var aggregatedHypha = AggregateHyphae(root);
    var hyphaKeys = new List&lt;HyphaKey&gt;(aggregatedHypha.Length);
    foreach (var hypha in aggregatedHypha) {
        hyphaKeys.Add(hypha.Key);
    }
    return [..hyphaKeys];
}
                    </code></pre>
				</section>
			</section>

			<section>
				<section>
					<h2>Unit Tests</h2>
				</section>
				<section>
					<h3>ATRIP Prinzipien</h3>
					<ul>
						<li><strong>A</strong>utomatic: Einsatz des MSTest-Frameworks.</li>
						<li><strong>T</strong>horough (Gr√ºndlich):
							<ul>
								<li>Code-Coverage nur bedingt gegeben (ca. 40%).</li>
								<li>Komplexere Algorithmen relativ ausf√ºhrlich & vereinzelt datengetrieben getestet.
								</li>
								<li>Abstraktionen m√ºssen nicht zwingend getestet werden.</li>
							</ul>
						</li>
						<li><strong>R</strong>epeatable: Tests liefern konsistente Ergebnisse. (implizit durch
							Automatisierung)</li>
						<li><strong>I</strong>ndependent: Tests beeinflussen sich nicht gegenseitig. (implizit durch
							Testaufbau)</li>
						<li><strong>P</strong>rofessional:
							<ul>
								<li>Deskriptive Test-Methoden-Namen (z.B. Name_Zustand_Verhalten).</li>
								<li>Datengetriebenes Testen.</li>
								<li>Strikter AAA-Aufbau (Arrange, Act, Assert).</li>
								<li>Schnelle Tests.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Die Unit-Tests folgen den ATRIP-Prinzipien: Sie sind automatisch (MSTest), wiederholbar und
						unabh√§ngig. Die Gr√ºndlichkeit (Thorough) ist mit einer Code Coverage von ca. 40%
						verbesserungsw√ºrdig, wobei komplexe Algorithmen gut abgedeckt sind. Professionalit√§t zeigt sich
						in Namenskonventionen, dem AAA-Pattern und datengetriebenen Ans√§tzen.
					</aside>
				</section>
				<section>
					<h3>Fakes und Mocks</h3>
					<ul>
						<li>Fake Factories (<code>FakeGardenFactory</code>, <code>FakePlantFactory</code>).</li>
						<li>Keine Evaluation wie Mocks, bieten Scaffolding (Testger√ºst).</li>
						<li>Instanziieren In-Memory-Repositories individuell pro Test-Kontext.</li>
						<li><em>Bezeichnung "Factory" ggf. nicht ideal; aktuell eher Helper. K√∂nnten zuk√ºnftig weitere
								Initialisierungsarten anbieten.</em></li>
					</ul>
					<aside class="notes">
						Anstelle von komplexen Mocks werden "Fake Factories" verwendet. Diese dienen dem schnellen
						Erstellen von Testdaten und der Initialisierung von In-Memory-Repositories f√ºr jeden Testlauf,
						um die Unabh√§ngigkeit der Tests zu gew√§hrleisten. Sie bieten ein Ger√ºst (Scaffolding) und f√ºhren
						keine Verhaltens√ºberpr√ºfungen durch, wie es typische Mocks tun w√ºrden.
					</aside>
				</section>
				<section>
					<h3>Code Coverage</h3>
					<ul>
						<li>Nur etwa 40% Testabdeckung.</li>
						<li>44 verschiedene Tests.</li>
						<li>Fokus prim√§r auf komplexere Konstrukte und Algorithmen.</li>
					</ul>
					<aside class="notes">
						Die Testabdeckung liegt bei etwa 40%, trotz einer soliden Anzahl von 44 Tests. Der Schwerpunkt
						der Tests liegt auf der Validierung komplexer Logik und Algorithmen.
					</aside>
				</section>
				<section>
					<h3>Ausgew√§hlte Unit Tests (1/5)</h3>
				</section>
				<section>
					<h4>1. <code>TestFingerprint.TestFingerprintTimestampExtraction()</code></h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Value Object <code>Fingerprint</code>.</li>
						<li><strong>Testet:</strong> Korrekte Extraktion des Erstellungszeitstempels aus einer GUID v7.
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public void TestFingerprintTimestampExtraction()
{
    var timestamps = new[]
    {
        DateTimeOffset.FromUnixTimeSeconds(987709362),
        DateTimeOffset.FromUnixTimeSeconds(1615676400),
        GetRandomDateTimeOffset()
    };
    var fingerprints = WrapFingerprints(WrapGuids(timestamps));
    var deserializedDateTime = new List<DateTimeOffset>(timestamps.Length);
    foreach (var fingerprint in fingerprints)
    {
        deserializedDateTime.Add(fingerprint.GetCreationDateTime());
    }
    for (int i = 0; i < fingerprints.Length; i++)
    {
        Assert.AreEqual(timestamps[i], deserializedDateTime[i]);
    }
}
                    </code></pre>
					<aside class="notes">
						Dieser Test stellt sicher, dass aus einem `Fingerprint`-Objekt (welches eine GUID v7 kapselt)
						der korrekte Unix-Zeitstempel seiner Erstellung extrahiert werden kann.
					</aside>
				</section>
				<section>
					<h4>2. <code>TestHyphaeHierarchy.ShouldResolveTertiaryHyphaeHierarchy()</code></h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Domain Service <code>HyphaeHierarchy</code>.</li>
						<li><strong>Testet:</strong> Korrekte Umwandlung einer 3-stufigen <code>Hypha</code>-Hierarchie
							in String-Form.</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public void ShouldResolveTertiaryHyphaeHierarchy()
{
    var delimiter = HyphaKey.ExtensionDelimiter;
    var hyphae = BuildHyphaeOfThree();
    var serializedHierarchy = HyphaeHierarchy.AsString(hyphae);
    Assert.AreEqual(
        $"Primary{delimiter}Secondary{delimiter}Tertiary",
        serializedHierarchy
        );
}
                    </code></pre>
					<aside class="notes">
						Dieser Test pr√ºft, ob der Domain Service `HyphaeHierarchy` eine verschachtelte, dreistufige
						Hypha-Struktur korrekt in ihre String-Repr√§sentation umwandeln kann.
					</aside>
				</section>
				<section>
					<h3>Ausgew√§hlte Unit Tests (2/5)</h3>
				</section>
				<section>
					<h4>3. <code>TestHyphaSerializer.TestSerializationCycleOfHyphaeHierarchyWithValue()</code></h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Application Service
							<code>HyphaeSerializationService</code>.
						</li>
						<li><strong>Testet:</strong> Korrekten Roundtrip (Serialisierung -> Deserialisierung ->
							Serialisierung) f√ºr einen <code>HyphaeStrain</code>.</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public void TestSerializationCycleOfHyphaeHierarchyWithValue()
{
    // Arrange
    var delimiter = HyphaKey.ExtensionDelimiter;
    var serializedHyphae = $"{HyphaKey.StartMarker}keyA{delimiter}keyB{delimiter}value";
    // Act
    var hyphae = HyphaeSerializationService.Deserialize(serializedHyphae).First();
    var newSerializedHyphae = HyphaeSerializationService.Serialize(hyphae);
    // Assert
    Assert.IsNotNull(hyphae);
    Assert.AreEqual(serializedHyphae, newSerializedHyphae);
}
                    </code></pre>
					<aside class="notes">
						Hier wird der Serialisierungs- und Deserialisierungsprozess f√ºr einen HyphaeStrain getestet. Ein
						String wird deserialisiert, das resultierende Objekt wieder serialisiert, und das Ergebnis muss
						dem urspr√ºnglichen String entsprechen.
					</aside>
				</section>
				<section>
					<h4>4. <code>PlacePlantTest.IntoGarden_ValidPlant_AssociatesWithMycelium()</code></h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>PlacePlant</code> (Erfolgsfall +
							Seiteneffekt).</li>
						<li><strong>Testet:</strong> Korrektes Platzieren einer <code>Plant</code> im
							<code>Garden</code> UND korrekte Verbindung mit <code>Mycelium</code>.
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task IntoGarden_ValidPlant_AssociatesWithMycelium()
{
    // # Arrange
    var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");
    var gardenRepo = new InMemoryGardenRepository([testGarden]);
    var arboretumRepo = new InMemoryArboretumRepository([testGarden]);
    var plantRepo = new InMemoryPlantRepository();
    var testPlant = FakePlantFactory.CreateTestPlant(
        "TestPlant",
        "#this-strain-should-absolutely-be-associated" +
        "#this-strain-should-be-associated-as-well", null, null);
    var testPlantDto = PlantMapper.IntoDto(testPlant);
    var gardenId = new GardenIdentifierInput(testGarden.UniqueMarker.ToString());
    var placePlantUseCae = new PlacePlant(arboretumRepo, gardenRepo, plantRepo);
    // # Act
    var result = await placePlantUseCae.IntoGarden(testPlantDto, gardenId);
    // # Assert
    Assert.IsTrue(result.IsSuccess);
    Assert.IsNotNull(result.Value);
    Assert.AreEqual("#TestPlant", result.Value.PrimaryPlantHyphae);
    var arboretum = arboretumRepo.Open();
    Assert.IsTrue(arboretum.Mycelium.ContainsMycorrhization(
        testPlant.Name, testPlant.UniqueMarker));
    Assert.IsTrue(arboretum.Mycelium.ContainsMycorrhizations(
        testPlant.AssociatedHyphae, testPlant.UniqueMarker));
}
                    </code></pre>
					<aside class="notes">
						Dieser Testfall f√ºr den `PlacePlant`-Use-Case pr√ºft nicht nur, ob eine Pflanze erfolgreich einem
						Garten hinzugef√ºgt wird, sondern auch den wichtigen Seiteneffekt, dass die Pflanze korrekt mit
						dem globalen Mycelium-Netzwerk verbunden wird.
					</aside>
				</section>
				<section>
					<h3>Ausgew√§hlte Unit Tests (3/5)</h3>
				</section>
				<section>
					<h4>5.
						<code>RetrievePlantsTest.GetPlantByFingerprintAsync_ExistingPlant_ReturnsSuccessWithPlantInGarden()</code>
					</h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>RetrievePlants</code> (Erfolgsfall, Single
							Item).</li>
						<li><strong>Testet:</strong> Korrektes Auffinden und Zur√ºckgeben einer einzelnen
							<code>Plant</code> (im Kontext ihres <code>Garden</code> DTOs) via <code>Fingerprint</code>.
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task GetPlantByFingerprintAsync_ExistingPlant_ReturnsSuccessWithPlantInGarden()
{
    // Arrange
    var plant1 = FakePlantFactory.CreateTestPlant("PlantA", "#HyphaA", 0, 0);
    var garden1 = FakeGardenFactory.CreateRawTestGarden("Garden1");
    garden1.AddPlant(plant1);
    var retrievePlantsUseCase = SetupRepositoriesAndUseCase(
        initialPlants: [plant1], initialGardens: [garden1]);
    var input = new PlantIdentifierInput(plant1.UniqueMarker.ToString());
    // Act
    var result = await retrievePlantsUseCase.GetPlantByFingerprintAsync(input);
    // Assert
    IsTrue(result.IsSuccess); IsNotNull(result.Value);
    AreEqual(1, result.Value.MatchingGardens.Count, "Should find the plant in one garden.");
    var gardenDto = result.Value.MatchingGardens[0];
    AreEqual(garden1.UniqueMarker.ToString(), gardenDto.UniqueMarker);
    AreEqual(1, gardenDto.Plants.Count);
    AreEqual(plant1.UniqueMarker.ToString(), gardenDto.Plants[0].UniqueMarker);
}
                    </code></pre>
					<aside class="notes">
						Dieser Test stellt sicher, dass der `RetrievePlants`-Use-Case eine existierende Pflanze anhand
						ihres Fingerprints korrekt findet und als DTO im Kontext ihres Gartens zur√ºckgibt.
					</aside>
				</section>
				<section>
					<h4>6.
						<code>RetrievePlantsTest.GetAllAsync_WhenGardensAndPlantsExist_ReturnsSuccessWithAllGardensAndPlants()</code>
					</h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>RetrievePlants</code> (Erfolgsfall,
							Multiple Items).</li>
						<li><strong>Testet:</strong> Korrektes Zur√ºckgeben aller <code>Gardens</code> mit ihren
							<code>Plants</code> als DTOs bei komplexerem Setup.
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task GetAllAsync_WhenGardensAndPlantsExist_ReturnsSuccessWithAllGardensAndPlants()
{
    // Arrange
    var plant1 = FakePlantFactory.CreateTestPlant("PlantA", "#HyphaA", 0, 0);
    var plant2 = FakePlantFactory.CreateTestPlant("PlantB", "#HyphaB", 0, 0);
    var garden1 = FakeGardenFactory.CreateRawTestGarden("Garden1"); garden1.AddPlant(plant1);
    var garden2 = FakeGardenFactory.CreateRawTestGarden("Garden2"); garden2.AddPlant(plant2);
    var retrievePlantsUseCase = SetupRepositoriesAndUseCase(
        initialPlants: [plant1, plant2], initialGardens: [garden1, garden2]);
    // Act
    var result = await retrievePlantsUseCase.GetAllAsync();
    // Assert
    IsTrue(result.IsSuccess); IsNotNull(result.Value);
    AreEqual(2, result.Value.MatchingGardens.Count, "Should return two gardens.");
    var garden1Dto = result.Value.MatchingGardens.FirstOrDefault(g => g.PrimaryLocation == garden1.PrimaryLocation.ToString());
    IsNotNull(garden1Dto); AreEqual(1, garden1Dto.Plants.Count); AreEqual(plant1.Name.ToString(), garden1Dto.Plants[0].PrimaryHyphae);
    // ... similar asserts for garden2Dto
}
                    </code></pre>
					<aside class="notes">
						Dieser Test validiert, dass der `RetrievePlants`-Use-Case bei einem Setup mit mehreren G√§rten
						und Pflanzen alle diese Entit√§ten korrekt als DTOs zur√ºckgibt.
					</aside>
				</section>
				<section>
					<h3>Ausgew√§hlte Unit Tests (4/5)</h3>
				</section>
				<section>
					<h4>7. <code>PlacePlantTest.IntoGarden_PlantAlreadyExists_ReturnsFailure()</code></h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>PlacePlant</code> (Fehlerfall,
							Gesch√§ftsregel).</li>
						<li><strong>Testet:</strong> Korrekte Fehlerbehandlung (via <code>Result</code> Pattern), wenn
							<code>Plant</code> doppelt hinzugef√ºgt wird.
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task IntoGarden_PlantAlreadyExists_ReturnsFailure()
{
    // Arrange
    var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");
    var gardenRepo = new InMemoryGardenRepository([testGarden]);
    var arboretumRepo = new InMemoryArboretumRepository([testGarden]);
    var plantRepo = new InMemoryPlantRepository();
    var testPlant = FakePlantFactory.CreateTestPlant("TestPlant", "...", null, null);
    var testPlantDto = PlantMapper.IntoDto(testPlant);
    var gardenId = new GardenIdentifierInput(testGarden.UniqueMarker.ToString());
    var placePlantUseCae = new PlacePlant(arboretumRepo, gardenRepo, plantRepo);
    // Act
    var firstResult = await placePlantUseCae.IntoGarden(testPlantDto, gardenId);
    var secondResult = await placePlantUseCae.IntoGarden(testPlantDto, gardenId);
    // Assert
    Assert.IsTrue(firstResult.IsSuccess);
    Assert.IsFalse(secondResult.IsSuccess);
    Assert.AreEqual(PlacePlantErrors.PlantAlreadyExists, secondResult.Error.Code);
}
                    </code></pre>
					<aside class="notes">
						Dieser Test pr√ºft eine Gesch√§ftsregel: Eine Pflanze darf nicht doppelt in einen Garten eingef√ºgt
						werden. Es wird erwartet, dass der zweite Versuch fehlschl√§gt und einen entsprechenden
						Fehlercode √ºber das `Result`-Pattern zur√ºckgibt.
					</aside>
				</section>
				<section>
					<h4>8.
						<code>RetrievePlantsTest.ByPrimaryHyphaeAsync_NonExistingPlant_ReturnsFailurePlantNotFound()</code>
					</h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>RetrievePlants</code> (Fehlerfall, "Not
							Found").</li>
						<li><strong>Testet:</strong> Korrekte Fehlerbehandlung, wenn <code>Plant</code> √ºber nicht
							existierenden prim√§ren <code>HyphaeStrain</code> gesucht wird.</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task ByPrimaryHyphaeAsync_NonExistingPlant_ReturnsFailurePlantNotFound()
{
    // Arrange
    var retrievePlantsUseCase = SetupRepositoriesAndUseCase();
    var input = new HyphaeStrainDto("#NonExistentPlant");
    // Act
    var result = await retrievePlantsUseCase.ByPrimaryHyphaeAsync(input);
    // Assert
    IsFalse(result.IsSuccess);
    AreEqual(RetrievePlantsError.PlantNotFound, result.Error.Code);
}
                    </code></pre>
					<aside class="notes">
						Dieser Testfall stellt sicher, dass der `RetrievePlants`-Use-Case korrekt mit der Situation
						umgeht, in der eine Pflanze anhand eines prim√§ren HyphaeStrains gesucht wird, der nicht
						existiert. Es wird ein Fehlschlag mit dem Fehlercode "PlantNotFound" erwartet.
					</aside>
				</section>
				<section>
					<h3>Ausgew√§hlte Unit Tests (5/5)</h3>
				</section>
				<section>
					<h4>9.
						<code>PlacePlantTest.IntoGardenWithoutAdditionalMycorrhization_ValidPlant_ReturnsSuccess()</code>
					</h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert spezielle Variante des <code>PlacePlant</code>-Use-Cases.
						</li>
						<li><strong>Testet:</strong> Erfolgreiches Hinzuf√ºgen einer <code>Plant</code> zum
							<code>Garden</code>, ohne zus√§tzliche Verbindung zum globalen <code>Mycelium</code> (au√üer
							Garten-Assoziation).
						</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[TestMethod]
public async Task IntoGardenWithoutAdditionalMycorrhization_ValidPlant_ReturnsSuccess()
{
    // # Arrange
    var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");
    var gardenRepo = new InMemoryGardenRepository([testGarden]); /* ... */
    var testPlant = FakePlantFactory.CreateTestPlant("TestPlant", "...", null, null);
    var placePlantUseCae = new PlacePlant(/*...*/);
    // # Act
    var result = await placePlantUseCae
        .IntoGardenWithoutAdditionalMycorrhization(PlantMapper.IntoDto(testPlant), new GardenIdentifierInput(testGarden.UniqueMarker.ToString()));
    // # Assert
    Assert.IsTrue(result.IsSuccess); /* ... */
    var arboretum = arboretumRepo.Open();
    Assert.IsFalse(arboretum.Mycelium.ContainsMycorrhization(testPlant.Name, testPlant.UniqueMarker));
    Assert.IsFalse(arboretum.Mycelium.ContainsMycorrhizations(testPlant.AssociatedHyphae, testPlant.UniqueMarker));
}
                    </code></pre>
					<aside class="notes">
						Dieser Testfall pr√ºft eine spezielle Funktionalit√§t des `PlacePlant`-Use-Cases: das Hinzuf√ºgen
						einer Pflanze zu einem Garten, wobei explizit keine weiteren Assoziationen im globalen Mycelium
						f√ºr diese Pflanze erstellt werden, abgesehen von der Zugeh√∂rigkeit zum Garten selbst.
					</aside>
				</section>
				<section>
					<h4>10. <code>RetrievePlantsTest.ByMyceliumQuery_VariousScenarios_ReturnsExpectedResult()</code>
					</h4>
					<ul>
						<li><strong>Zweck:</strong> Validiert Use Case <code>RetrievePlants</code> (Datengetriebener
							Test).</li>
						<li><strong>Testet:</strong> Mehrere Query-Szenarien (AND/OR/NOT) effizient gegen erwartete
							Ergebnisse (Erfolg/Fehler, Anzahl Treffer).</li>
					</ul>
					<pre><code class="csharp" data-trim data-noescape>
[DataTestMethod]
[DynamicData(nameof(GetMyceliumQueryTestCases), DynamicDataSourceType.Method)]
public async Task ByMyceliumQuery_VariousScenarios_ReturnsExpectedResult(MyceliumQueryTestCase testCase)
{
    // Arrange
    var retrievePlantsUseCase = SetupForMyceliumQueryTests();
    var input = new QueryMyceliumInput(testCase.HyphaeQuery);
    // Act
    var result = await retrievePlantsUseCase.ByMyceliumQuery(input);
    // Assert
    AreEqual(testCase.ExpectedSuccess, result.IsSuccess, ...);
    if (testCase.ExpectedSuccess)
    {
        IsNotNull(result.Value, ...);
        AreEqual(testCase.ExpectedGardenCount, result.Value.MatchingGardens.Count, ...);
        // ... more asserts for plant counts and specific cases
    }
    else { /* Assert error details */ }
}
                    </code></pre>
					<aside class="notes">
						Dies ist ein datengetriebener Test, der verschiedene Abfrageszenarien f√ºr das Mycelium (mit
						AND-, OR- und NOT-Logik) testet. Durch die Verwendung von `DynamicData` k√∂nnen mehrere Testf√§lle
						mit unterschiedlichen Eingaben und erwarteten Ergebnissen effizient durchlaufen werden.
					</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>Domain Driven Design (DDD)</h2>
				</section>
				<section>
					<h3>Ubiquitous Language (Allgegenw√§rtige Sprache) - Teil 1</h3>
					<ul>
						<li><strong>Arboretum:</strong> Gesamtsystem; enth√§lt <code>Gardens</code>, zentrales
							<code>Mycelium</code>.
						</li>
						<li><strong>Garden:</strong> (Aggregat) Container/Namespace f√ºr <code>Plants</code>;
							<code>Fingerprint</code>, <code>PrimaryLocation</code> (<code>HyphaeStrain</code>).
							Verwaltet <code>Plants</code>.
						</li>
						<li><strong>Plant:</strong> (Entit√§t) Zentrale Info-Einheit (z.B. Datei);
							<code>Fingerprint</code>, <code>Name</code> (<code>HyphaeStrain</code>),
							<code>AssociatedHyphae</code>, besteht aus <code>Cells</code>.
						</li>
						<li><strong>Cell:</strong> (Wertobjekt/Entit√§t) Kleinste Dateneinheit einer <code>Plant</code>;
							verweist via <code>OrganellLocation</code> (<code>HyphaeStrain</code>) auf Daten;
							<code>Fingerprint</code>, <code>CellType</code>.
						</li>
					</ul>
					<aside class="notes">
						Die Ubiquitous Language ist ein Kernkonzept des DDD und bezeichnet eine gemeinsame Sprache, die
						von allen Teammitgliedern (Entwickler, Fachexperten) verwendet wird.
						Das Arboretum ist das Wurzelelement. G√§rten sind Aggregate Roots, die Pflanzen enthalten.
						Pflanzen sind Entit√§ten mit Zellen.
					</aside>
				</section>
				<section>
					<h3>Ubiquitous Language (Allgegenw√§rtige Sprache) - Teil 2</h3>
					<ul>
						<li><strong>Mycelium:</strong> (Aggregat/Domain Service) Zentrales Beziehungsnetzwerk; verbindet
							<code>Plants</code> (<code>Mycorrhization</code>) & <code>Gardens</code>
							(<code>Association</code>) √ºber <code>HyphaeStrains</code>; erm√∂glicht <code>Queries</code>.
						</li>
						<li><strong>Hypha:</strong> (Wertobjekt) Atomarer Baustein einer Beziehung/eines Attributs
							(<code>HyphaKey</code> + Wert); kann hierarchisch sein.</li>
						<li><strong>HyphaeStrain:</strong> (Wertobjekt) Spezifische, unver√§nderliche Sequenz von
							<code>Hypha</code>-Objekten; repr√§sentiert Attributpfad/Beziehungsschl√ºssel.
						</li>
						<li><strong>HyphaKey:</strong> (Wertobjekt) Reiner Schl√ºssel/Bezeichner-Teil einer
							<code>Hypha</code>.
						</li>
						<li><strong>HyphaApex:</strong> (Wertobjekt) Atomare <code>Hypha</code>, nur
							<code>HyphaKey</code> (wie Tag).
						</li>
					</ul>
					<aside class="notes">
						Das Mycelium ist das Kernnetzwerk. Hyphae, HyphaeStrains, HyphaKeys und HyphaApex sind Bausteine
						f√ºr Attribute und Beziehungen.
					</aside>
				</section>
				<section>
					<h3>Ubiquitous Language (Allgegenw√§rtige Sprache) - Teil 3</h3>
					<ul>
						<li><strong>Fingerprint:</strong> (Wertobjekt) Eindeutiger, zeitbasierter Identifikator (GUID
							v7) f√ºr <code>Plant</code>, <code>Garden</code>, <code>Cell</code>.</li>
						<li><strong>Mycorrhization / Mycorrhizate:</strong> (Dom√§nenverb/-nomen) Prozess/Zustand der
							Verbindung einer <code>Plant</code> mit <code>Mycelium</code> via
							<code>HyphaeStrains</code>.
						</li>
						<li><strong>Association:</strong> (Dom√§nennomen) Allgemeine Verbindung im <code>Mycelium</code>
							(z.B. Garden &lt;-&gt; HyphaeStrain).</li>
						<li><strong>Query:</strong> (Anwendungs-/Dom√§nenaufgabe) Anfrage an <code>Mycelium</code> zum
							Finden von Elementen basierend auf <code>HyphaeStrain</code>-Kriterien (AND/OR/NOT).</li>
						<li><strong>Cultivate / Cross:</strong> (Dom√§nenverben) Aktionen auf <code>Plants</code> zur
							Erzeugung neuer Versionen/Kombinationen.</li>
						<li><strong>PhenotypedPlant:</strong> (Memento) Unver√§nderlicher Schnappschuss des Zustands
							einer <code>Plant</code>.</li>
					</ul>
					<aside class="notes">
						Fingerprints dienen der Identifikation. Mycorrhization und Association beschreiben Verbindungen.
						Queries dienen der Suche. Cultivate und Cross sind Dom√§nenaktionen, PhenotypedPlant ein
						Zustandssnapshot.
					</aside>
				</section>
				<section>
					<h3>Repositories</h3>
					<ul>
						<li>Abstraktionsschicht f√ºr Datenzugriff (z.B. <code>IPlantRepository</code>,
							<code>IGardenRepository</code>).
						</li>
						<li>Entkoppeln Details des Datenzugriffs (Speichern, Laden, etc.) von Anwendungslogik.</li>
						<li>Use Cases & Services (<code>PlacePlant</code>, <code>RetrievePlants</code>,
							<code>MyceliumQueryService</code>) interagieren nur mit Interfaces.
						</li>
						<li>Konkrete Implementierungen (<code>InMemory...</code>) via Dependency Injection.</li>
					</ul>
					<aside class="notes">
						Repositories, wie `IPlantRepository` und `IGardenRepository`, dienen als Abstraktionsschicht, um
						die Details des Datenzugriffs (z. B. Speichern, Laden, Aktualisieren von `Plants` oder
						`Gardens`) von der restlichen Anwendungslogik zu entkoppeln. Die Use Cases und Services
						interagieren ausschlie√ülich mit diesen Interfaces und erhalten die konkreten
						Repository-Implementierungen (aktuell die `InMemory...`-Versionen) √ºber Dependency Injection im
						Konstruktor. Dies f√∂rdert die Testbarkeit und Flexibilit√§t des Systems.
					</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>Refactoring</h2>
				</section>
				<section>
					<h3>Code Smells - Identifikation</h3>
				</section>
				<section>
					<h4>Shotgun Surgery: <code>HyphaeStrain</code></h4>
					<ul>
						<li>Klasse zieht sich durch Dom√§nen- und Applikations-Schicht.</li>
						<li>√Ñnderung f√ºhrt zu vielen Folge√§nderungen (bedingt "by Design").</li>
						<li>Bionik: Hyphe als √úbertragungsnetz.</li>
						<li>Zuk√ºnftige Features (N√§hrstoff-/Info-Austausch): Spezielle Kindklassen erstellen.</li>
					</ul>
					<aside class="notes">
						Die Klasse `HyphaeStrain` ist ein Kandidat f√ºr "Shotgun Surgery". Aufgrund ihrer zentralen Rolle
						als √úbertragungsmechanismus (analog zu Hyphen in der Natur) sind √Ñnderungen an ihr oft mit
						Anpassungen an vielen Stellen im Code verbunden. Dies ist teilweise designbedingt. F√ºr
						zuk√ºnftige Erweiterungen sollten spezialisierte Kindklassen in Betracht gezogen werden, um die
						Auswirkungen von √Ñnderungen zu begrenzen.
					</aside>
				</section>
				<section>
					<h4>Bloater: <code>MyceliumQueryService</code></h4>
					<ul>
						<li>Zu gro√üe Klasse, viele Methoden, wenig √ºbersichtlich.</li>
						<li>Wird vorerst nicht bereinigt (funktional).</li>
						<li>Ideale Erweiterung der Sprache: Vollst√§ndiger Compiler-Prozess.
							<ul>
								<li>Lexer-, Parser-, SemanticAnalysis-, Optimization-, CodeGeneration-Klassen.</li>
								<li>Dediziertes Objektmodell (<code>Query</code>, <code>AndCriteria</code>, etc.).</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Der `MyceliumQueryService` ist ein "Bloater" ‚Äì eine zu gro√üe Klasse mit zu vielen
						Verantwortlichkeiten, was die √úbersichtlichkeit und Wartbarkeit erschwert. Obwohl funktional,
						w√§re eine zuk√ºnftige Aufteilung in spezialisierte Komponenten eines Compiler-Prozesses (Lexer,
						Parser etc.) mit einem eigenen Objektmodell f√ºr Queries ideal.
					</aside>
				</section>
				<section>
					<h4>Feature Envy (& Method-Bloat): <code>GroupPlantsIntoGardens</code></h4>
					<ul>
						<li>Methode in <code>MyceliumQueryService</code>.</li>
						<li>Sollte in <code>GardenResultMapper</code> (o.√§.) ausgelagert werden.</li>
						<li>Grund: Starke Kopplung an <code>Garden</code>, <code>Plant</code>, deren DTOs (nicht prim√§r
							Bloating).</li>
						<li>Ideal: Beziehung <code>Plant</code> -> <code>Garden</code> (invers) bereits in Dom√§ne
							aufl√∂sen.
							<ul>
								<li>Z.B. Garden-Assoziationen in <code>Plant</code>-Instanz (wie in
									<code>Mycelium</code>) gesondert behandeln.
								</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Die Methode `GroupPlantsIntoGardens` im `MyceliumQueryService` zeigt "Feature Envy", da sie
						stark auf Daten und Logik anderer Klassen (insbesondere `Garden` und `Plant` sowie deren DTOs)
						zugreift. Eine Auslagerung in eine dedizierte Mapper-Klasse w√§re sinnvoll. Langfristig k√∂nnte
						die inverse Beziehung von Pflanze zu Garten direkt im Dom√§nenmodell abgebildet werden.
					</aside>
				</section>
				<section>
					<h3>1. Refactoring: <code>Mycelium</code>-Klasse</h3>
				</section>
				<section>
					<h4>Problem & Ziel</h4>
					<ul>
						<li><code>Mycelium</code> stark angeschwollen (ca. 300 Zeilen).</li>
						<li>√úbernimmt vermehrt Aufgaben zu Assoziation & Mycorrhization.</li>
						<li>Problem: Trennbarkeit von Pflanzen und G√§rten (beide mit Fingerprints identifiziert).</li>
						<li>Refactoring-Ziel: Eindeutigkeit herstellen (nur <code>Plant</code>-Instanzen k√∂nnen
							mycorrhiziert werden).</li>
						<li>Streichen ungenutzter Methoden -> kompaktere Klasse.</li>
					</ul>
					<aside class="notes">
						Die `Mycelium`-Klasse war zu gro√ü geworden und hatte Probleme mit der eindeutigen Unterscheidung
						von Pflanzen- und Garten-Assoziationen, da beide √ºber Fingerprints identifiziert wurden. Ziel
						des Refactorings war es, klarzustellen, dass nur Pflanzen "mycorrhiziert" werden k√∂nnen, und
						ungenutzte Methoden zu entfernen, um die Klasse zu verkleinern.
					</aside>
				</section>
				<section>
					<h4>Ergebnis & Ausblick</h4>
					<ul>
						<li>API blieb gleich, abh√§ngige Klassen unver√§ndert.</li>
						<li>Korrigierte Erwartungshaltung: <code>GetMycorrhization(s)</code> gibt nur
							<code>Plant</code>-Fingerprints zur√ºck.
						</li>
						<li><em>Auslagerung in <code>MyceliumAssociation</code>-Klasse: W√§re keine reine
								Refactoring-Ma√ünahme (API-√Ñnderung), aber zuk√ºnftig sinnvoll.</em></li>
						<li>Commits: <code>6e0dc69...</code>, <code>92cb4a9...</code></li>
					</ul>
					<aside class="notes">
						Das Refactoring konnte ohne API-√Ñnderungen durchgef√ºhrt werden. Die Methoden
						`GetMycorrhization(s)` liefern nun erwartungsgem√§√ü nur Fingerprints von Pflanzen. Eine
						weitergehende Zerlegung in eine `MyceliumAssociation`-Klasse w√§re ein gr√∂√üerer Schritt und kein
						reines Refactoring gewesen, bleibt aber eine Option f√ºr die Zukunft.
					</aside>
				</section>
				<section>
					<h4>Refactoring <code>Mycelium</code>: UML Vorher - Einleitung</h4>
					<p>Das urspr√ºngliche Klassendiagramm von <code>Mycelium</code> zeigt eine breite API mit Methoden
						f√ºr allgemeine Assoziationen und spezifische Mykorrhizierungen, was zu Unklarheiten f√ºhren
						konnte.</p>
				</section>
				<section>
					<h4>Refactoring <code>Mycelium</code>: UML Vorher</h4>
					<div class="mermaid">
						classDiagram
						%% Core Mycelium Class with Fields
						class Mycelium {
						- _hyphalPlexus: ConcurrentDictionary~HyphaKey, HashSet HyphaeStrain ~
						- _mycorrhizalAssociations: ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint ~
						+ Mycelium(IList~Hypha~ hyphae, ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint ~
						mycorrhizalAssociations)
						+ Mycelium(IList~HyphaeStrain~ hyphaeStrains, ConcurrentDictionary~HyphaeStrain, HashSet
						Fingerprint ~ mycorrhizalAssociations)
						+ Mycelium()
						- ExtendWith(IList~HyphaeStrain~ hyphaeStrains) Mycelium
						- ExtendWith(HyphaeStrain hyphaeStrain) Mycelium
						- ExtendWith(IEnumerable~Hypha~ hyphae) Mycelium
						+ ExtendWith(Hypha hypha) Mycelium
						+ Contains(ImmutableArray~Hypha~ flatHyphae) bool
						+ Contains(Hypha hypha) bool
						+ Contains(HyphaeStrain hyphae) bool
						+ AssociateWith(Hypha hypha, Fingerprint association) Mycelium
						+ AssociateWith(IEnumerable~Hypha~ hyphae, Fingerprint association) Mycelium
						+ AssociateWith(HyphaeStrain strain, Fingerprint association) Mycelium
						+ AssociateWith(IEnumerable~HyphaeStrain~ hyphaeStrains, Fingerprint plantUniqueMarker) void
						+ Mycorrhizate(Plant plant) void
						+ ContainsMycorrhization(HyphaeStrain hyphae, Fingerprint association) bool
						+ ContainsMycorrhization(Hypha hyphae, Fingerprint association) bool
						+ ContainsMycorrhizations(IEnumerable~Hypha~ manyHyphae, Fingerprint association) bool
						+ ContainsMycorrhizations(IEnumerable~HyphaeStrain~ manyHyphae, Fingerprint association) bool
						+ GetMycorrhization(HyphaeStrain hyphae) ImmutableList~Fingerprint~
						+ GetMycorrhizations(IList~HyphaeStrain~ hyphaeStrains) ImmutableDictionary~HyphaeStrain,
						ImmutableList~Fingerprint~~
						+ GetAllMycorrhizations() ImmutableDictionary~HyphaeStrain, HashSet~Fingerprint~~
						}
						%% Classes/Types Mycelium Directly Depends On
						class HyphaeStrain { <<Aggregate Root>> }
							class Fingerprint { <<Value Object>> }
								class Plant { <<Entity>> }
									Mycelium --> HyphaeStrain : uses
									Mycelium --> Fingerprint : uses
									Mycelium --> Plant : uses in methods
					</div>
					<aside class="notes">UML des `Mycelium` vor dem Refactoring. Es zeigt eine Vielzahl von Methoden zur
						Assoziation und Mykorrhizierung, die teilweise generisch mit Fingerprints arbeiten.</aside>
				</section>
				<section>
					<h4>Refactoring <code>Mycelium</code>: UML Nachher - Einleitung</h4>
					<p>Das refaktorierte Klassendiagramm von <code>Mycelium</code> zeigt eine klarere Trennung zwischen
						Pflanzen-Mykorrhizierungen und Garten-Assoziationen sowie eine reduzierte API.</p>
				</section>
				<section>
					<h4>Refactoring <code>Mycelium</code>: UML Nachher</h4>
					<div class="mermaid">
						classDiagram
						¬† ¬† direction LR
						
						¬† ¬† class MyceliumQueryService {
						¬† ¬† ¬† ¬† -IArboretumRepository _arboretumRepo
						¬† ¬† ¬† ¬† -IPlantRepository _plantRepo
						¬† ¬† ¬† ¬† 
						¬† ¬† ¬† ¬† +FindAllByHyphaeQueryAsync(QueryMyceliumInput) Task~Result~MyceliumQuerySuccess, MyceliumQueryError~~
						¬† ¬† ¬† ¬† +GroupPlantsIntoGardens(IList~Fingerprint~) Task~Result~MyceliumQuerySuccess, MyceliumQueryError~~
						¬† ¬† ¬† ¬† -MapParserErrorToServiceError(MyceliumQueryParserError) MyceliumQueryError
						¬† ¬† }
						
						¬† ¬† class HyphaeQueryParser {
						¬† ¬† ¬† ¬† %% Private Konstanten/statische Felder sind konzeptionell Teil der Klasse
						¬† ¬† ¬† ¬† -OR_MARKER : char
						¬† ¬† ¬† ¬† -NOT_MARKER : char
						¬† ¬† ¬† ¬† -HYPHAE_START_MARKER : char
						¬† ¬† ¬† ¬† +Parse(string query) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
						¬† ¬† ¬† ¬† -ParseAndGroup(sring andGroupString) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
						¬† ¬† ¬† ¬† -TokenizeAndGroup(string groupString) List~TermToken~
						¬† ¬† }
						¬† ¬† %% Der private Record TermToken innerhalb von HyphaeQueryParser
						¬† ¬† class TermToken {
						¬† ¬† ¬† ¬† <<record>>
						¬† ¬† ¬† ¬† +Term : string
						¬† ¬† ¬† ¬† +IsNegated : bool
						¬† ¬† }
						
						  
						¬† ¬† class MyceliumContext {
						¬† ¬† ¬† ¬† +Mycelium Mycelium
						¬† ¬† }
						  
						¬† ¬† class IHyphaeQueryExpression {
						¬† ¬† ¬† ¬† <<interface>>
						¬† ¬† ¬† ¬† +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
						¬† ¬† }
						  
						¬† ¬† class TerminalHyphaeExpression {
						¬† ¬† ¬† ¬† -HyphaeStrain _strain
						¬† ¬† ¬† ¬† +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
						¬† ¬† }
						  
						¬† ¬† class AndExpression {
						¬† ¬† ¬† ¬† -IHyphaeQueryExpression _left
						¬† ¬† ¬† ¬† -IHyphaeQueryExpression _right
						¬† ¬† ¬† ¬† +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
						¬† ¬† }
						  
						¬† ¬† class OrExpression {
						¬† ¬† ¬† ¬† -IHyphaeQueryExpression _left
						¬† ¬† ¬† ¬† -IHyphaeQueryExpression _right
						¬† ¬† ¬† ¬† +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
						¬† ¬† }
						  
						¬† ¬† class NotExpression {
						¬† ¬† ¬† ¬† -IHyphaeQueryExpression _expression
						¬† ¬† ¬† ¬† +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
						¬† ¬† }
						  
						¬† ¬† %% Externe, aber direkt relevante Klassen (nur Namen)
						¬† ¬† class QueryMyceliumInput
						¬† ¬† class MyceliumQuerySuccess
						¬† ¬† class MyceliumQueryError
						¬† ¬† class MyceliumQueryParserError
						¬† ¬† class Fingerprint
						¬† ¬† class Mycelium
						¬† ¬† class HyphaeStrain
						¬† ¬† class IArboretumRepository
						¬† ¬† class IPlantRepository
						¬† ¬† class HyphaeSerializationService
						  
						¬† ¬† %% Beziehungen
						¬† ¬† MyceliumQueryService ..> HyphaeQueryParser : uses
						¬† ¬† MyceliumQueryService ..> MyceliumContext : creates
						¬† ¬† MyceliumQueryService ..> Mycelium : uses (to create context)
						¬† ¬† MyceliumQueryService ..> IArboretumRepository : uses
						¬† ¬† MyceliumQueryService ..> IPlantRepository : uses
						¬† ¬† MyceliumQueryService ..> QueryMyceliumInput : receives
						¬† ¬† MyceliumQueryService ..> MyceliumQuerySuccess : returns
						¬† ¬† MyceliumQueryService ..> MyceliumQueryError : returns
						  
						¬† ¬† HyphaeQueryParser ..> IHyphaeQueryExpression : creates
						¬† ¬† HyphaeQueryParser ..> TerminalHyphaeExpression : creates
						¬† ¬† HyphaeQueryParser ..> AndExpression : creates
						¬† ¬† HyphaeQueryParser ..> OrExpression : creates
						¬† ¬† HyphaeQueryParser ..> NotExpression : creates
						¬† ¬† HyphaeQueryParser ..> TermToken : uses (creates instances of private record)
						¬† ¬† HyphaeQueryParser ..> HyphaeSerializationService : uses
						¬† ¬† HyphaeQueryParser ..> MyceliumQueryParserError : returns
						
						  
						¬† ¬† IHyphaeQueryExpression <|.. TerminalHyphaeExpression
						¬† ¬† IHyphaeQueryExpression <|.. AndExpression
						¬† ¬† IHyphaeQueryExpression <|.. OrExpression
						¬† ¬† IHyphaeQueryExpression <|.. NotExpression
						  
						¬† ¬† TerminalHyphaeExpression ..> MyceliumContext : uses
						¬† ¬† TerminalHyphaeExpression ..> HyphaeStrain : uses
						¬† ¬† AndExpression ..> MyceliumContext : uses
						¬† ¬† AndExpression o-- IHyphaeQueryExpression : aggregates (left)
						¬† ¬† AndExpression o-- IHyphaeQueryExpression : aggregates (right)
						¬† ¬† OrExpression ..> MyceliumContext : uses
						¬† ¬† OrExpression o-- IHyphaeQueryExpression : aggregates (left)
						¬† ¬† OrExpression o-- IHyphaeQueryExpression : aggregates (right)
						¬† ¬† NotExpression ..> MyceliumContext : uses
						¬† ¬† NotExpression o-- IHyphaeQueryExpression : aggregates
						  
						¬† ¬† MyceliumContext ..> Mycelium : uses
						  
						¬† ¬† %% Weitere Relationen zu externen Klassen (vereinfacht)
						¬† ¬† TerminalHyphaeExpression ..> Fingerprint : returns via Interpret
						¬† ¬† AndExpression ..> Fingerprint : returns via Interpret
						¬† ¬† OrExpression ..> Fingerprint : returns via Interpret
						¬† ¬† NotExpression ..> Fingerprint : returns via Interpret
					</div>
					<aside class="notes">UML des `Mycelium` nach dem Refactoring. Interne Datenstrukturen sind nun
						spezifischer (`_plantMycorrhizations`, `_gardenAssociations`), und die API ist fokussierter. Die
						Methode `AssociateWithGarden` wurde eingef√ºhrt, und Methoden wie `GetMycorrhization` beziehen
						sich nun eindeutig auf Pflanzen.</aside>
				</section>
				<section>
					<h3>2. Refactoring: <code>MyceliumQueryService</code> Zerlegung</h3>
				</section>
				<section>
					<h4>Problem & Ziel</h4>
					<ul>
						<li><code>MyceliumQueryService</code> ist ein Bloater.</li>
						<li>Ziel: Parser-Logik (3 Schritte) extrahieren, Service vereinfachen.</li>
						<li>Ansatz (Bottom-Up):
							<ol>
								<li>Sprachkonstrukt definieren (<code>Or</code>, <code>And</code>, <code>Not</code>
									Ausdr√ºcke).</li>
								<li>Zusammenf√ºhren in <code>HyphaeQueryParser</code>.</li>
								<li>Beibehaltung der semantischen Bearbeitungs-Reihenfolge.</li>
							</ol>
						</li>
					</ul>
					<aside class="notes">
						Der `MyceliumQueryService` war zu gro√ü und komplex. Ziel des Refactorings war es, die
						Parser-Logik f√ºr die Query-Sprache in eine eigene Komponente (`HyphaeQueryParser`) auszulagern.
						Dies erfolgte durch die Definition der einzelnen Sprachausdr√ºcke (AND, OR, NOT) und deren
						Verarbeitung im neuen Parser, wobei die bestehende Logik beibehalten wurde.
					</aside>
				</section>
				<section>
					<h4>Refactoring <code>MyceliumQueryService</code>: UML Vorher - Einleitung</h4>
					<p>Das urspr√ºngliche Diagramm des <code>MyceliumQueryService</code> zeigt eine Klasse mit vielen
						internen Parsing- und Query-Methoden, was auf eine hohe Komplexit√§t und mehrere
						Verantwortlichkeiten hindeutet.</p>
				</section>
				<section>
					<h4>Refactoring <code>MyceliumQueryService</code>: UML Vorher</h4>
					<div class="mermaid">
						classDiagram
						%% The Service being described
						class MyceliumQueryService {
						<<Service>>
							%% Fields representing dependencies
							- _arboretumRepo IArboretumRepository
							- _plantRepo IPlantRepository
							- mycelium Mycelium %% Instance obtained via _arboretumRepo
							#Key Public Methods:
							+ FindAllByHyphaeQueryAsync(QueryMyceliumInput hyphaeQuery) Task
							Result~MyceliumQuerySuccess, MyceliumQueryError~
							+ GroupPlantsIntoGardens(IList~Fingerprint~ plantIdentifyingFingerprints) Task
							Result~MyceliumQuerySuccess, MyceliumQueryError~
							# Private Methods
							- FindAllInSingleOrBucket(string orBucket) Task Result~...~
							- QueryMyceliumIntersection(plainHyphae, negatedHyphae) Task Result~...~
							- QueryMyceliumNegatedAll(IList~HyphaeStrain~ negated) Task Result~...~
							- QueryMyceliumMixedIntersection(plainHyphae, negatedHyphae) Task Result~...~
							}
							%% Interfaces the Service Depends On
							class IArboretumRepository { <<interface>> }
								class IPlantRepository { <<interface>> }
									class Mycelium { <<Aggregate Root>> }
										class QueryMyceliumInput { <<DTO>> }
											MyceliumQueryService --> IArboretumRepository : uses
											MyceliumQueryService --> IPlantRepository : uses
											MyceliumQueryService --> Mycelium : uses methods of
											MyceliumQueryService --> QueryMyceliumInput : input
					</div>
					<aside class="notes">UML des `MyceliumQueryService` vor der Zerlegung. Die Klasse enth√§lt sowohl die
						√∂ffentliche API als auch die komplexe interne Logik zur Verarbeitung von Query-Strings.</aside>
				</section>
				<section>
					<h4>Refactoring <code>MyceliumQueryService</code>: UML Nachher - Einleitung</h4>
					<p>Nach dem Refactoring wurde die Parsing-Logik in den <code>HyphaeQueryParser</code> und ein System
						von Ausdrucksklassen ausgelagert. Der <code>MyceliumQueryService</code> ist nun schlanker und
						delegiert die Parsing-Aufgaben.</p>
					<p>Commit: <code>4f9b678...</code> (‚ö†Ô∏è 2 Tests failen bewusst).</p>
				</section>
				<section>
					<h4>Refactoring <code>MyceliumQueryService</code>: UML Nachher</h4>
					<div class="mermaid">
						classDiagram
						direction LR
						class MyceliumQueryService {
						-IArboretumRepository _arboretumRepo
						-IPlantRepository _plantRepo
						+FindAllByHyphaeQueryAsync(QueryMyceliumInput) Task~Result~MyceliumQuerySuccess,
						MyceliumQueryError~~
						+GroupPlantsIntoGardens(IList~Fingerprint~) Task~Result~MyceliumQuerySuccess,
						MyceliumQueryError~~
						-MapParserErrorToServiceError(MyceliumQueryParserError) MyceliumQueryError
						}
						class HyphaeQueryParser {
						+Parse(string query) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
						-ParseAndGroup(sring andGroupString) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
						-TokenizeAndGroup(string groupString) List~TermToken~
						}
						class TermToken { <<record>> }
							class MyceliumContext { +Mycelium Mycelium }
							class IHyphaeQueryExpression { <<interface>> +Interpret(MyceliumContext context)
								ImmutableList~Fingerprint~ }
								class TerminalHyphaeExpression { +Interpret(MyceliumContext context)
								ImmutableList~Fingerprint~ }
								class AndExpression { +Interpret(MyceliumContext context) ImmutableList~Fingerprint~ }
								class OrExpression { +Interpret(MyceliumContext context) ImmutableList~Fingerprint~ }
								class NotExpression { +Interpret(MyceliumContext context) ImmutableList~Fingerprint~ }
								class QueryMyceliumInput
								class Mycelium
								class Fingerprint

								MyceliumQueryService ..> HyphaeQueryParser : uses
								MyceliumQueryService ..> MyceliumContext : creates
								HyphaeQueryParser ..> IHyphaeQueryExpression : creates
								IHyphaeQueryExpression <|.. TerminalHyphaeExpression IHyphaeQueryExpression <|..
									AndExpression IHyphaeQueryExpression <|.. OrExpression IHyphaeQueryExpression <|..
									NotExpression AndExpression o-- IHyphaeQueryExpression OrExpression o--
									IHyphaeQueryExpression NotExpression o-- IHyphaeQueryExpression MyceliumContext ..>
									Mycelium : uses
					</div>
					<aside class="notes">UML des `MyceliumQueryService` nach der Zerlegung. Die Parsing-Logik ist nun im
						`HyphaeQueryParser` und den `IHyphaeQueryExpression`-Implementierungen gekapselt. Der Service
						selbst ist einfacher und delegiert die Query-Analyse. Zwei Tests schlagen nach diesem
						Refactoring bewusst fehl, da sie vorher leere Ergebnisse lieferten, was nun als Fehler
						interpretiert wird.</aside>
				</section>
			</section>

			<section>
				<section>
					<h2>Entwurfsmuster</h2>
				</section>
				<section>
					<h3>Builder: <code>HyphaeBuilder</code> - Einleitung</h3>
					<p>Der <code>HyphaeBuilder</code> ist ein Beispiel f√ºr das Builder-Entwurfsmuster. Er erm√∂glicht die
						schrittweise Konstruktion komplexer, hierarchischer <code>Hypha</code>-Objekte. Dies verbessert
						die Lesbarkeit und vereinfacht die Erstellung von Hypha-Strukturen im Vergleich zu einem
						Konstruktor mit vielen Parametern.</p>
				</section>
				<section>
					<h3>Builder: <code>HyphaeBuilder</code></h3>
					<div class="mermaid">
						classDiagram
						class HyphaeBuilder {
						-List~HyphaKey~ _hyphaeStrain
						-Hypha _root
						+HyphaeBuilder(Hypha root, List~HyphaKey~?)
						+ExtendBy(HyphaKey) HyphaeBuilder
						+ExtendBy(Hypha) HyphaeBuilder
						+Build() Hypha
						}
						class Hypha {
						+Key: HyphaKey
						+Value: object
						+NextExtension() Hypha?
						+DoesExtend() bool
						}
						class HyphaKey {
						+Value: string
						}
						class HyphaeSerializationService {
						<<static>> +Deserialize(string) ImmutableList~HyphaeStrain~
							<<static>> -ParseHypha(string) HyphaeStrain
								<<static>> +Serialize(Hypha) string
									}
									HyphaeBuilder ..> Hypha : builds
									HyphaeBuilder ..> HyphaKey : uses
									HyphaeSerializationService ..> HyphaeBuilder : uses (within ParseHypha)
					</div>
					<aside class="notes">
						Der `HyphaeBuilder` wird verwendet, um komplexe, m√∂glicherweise hierarchische `Hypha`-Objekte
						schrittweise zu erstellen. Er wird beispielsweise vom `HyphaeSerializationService` beim
						Deserialisieren von Hypha-Strings genutzt. Das Builder-Pattern hilft, den Konstruktionsprozess
						von der Repr√§sentation des Objekts zu trennen.
					</aside>
				</section>
				<section>
					<h3>Data Mapper: <code>PlantMapper</code> - Einleitung</h3>
					<p>Der <code>PlantMapper</code> (und analog <code>GardenMapper</code>) implementiert das Data
						Mapper-Muster. Er ist verantwortlich f√ºr die √úbertragung von Daten zwischen Dom√§nenobjekten
						(z.B. <code>Plant</code>) und Daten√ºbertragungsobjekten (DTOs, z.B. <code>PlantDto</code>). Dies
						entkoppelt die Dom√§nenschicht von der Datenrepr√§sentation in anderen Schichten.</p>
				</section>
				<section>
					<h3>Data Mapper: <code>PlantMapper</code></h3>
					<div class="mermaid">
						classDiagram
						direction LR
						class PlantMapper {
						<<static>>
							+IntoPlant(PlantDto plantTemplate) Plant
							+IntoDto(Plant plant) PlantDto
							}
							class Plant { <<Domain Entity>> }
								class PlantDto { <<Data Transfer Object>> }
									class Cell { }
									class CellDto { }
									class HyphaeStrain { }
									class HyphaeSerializationService { <<static>> }
										class GardenMapper { <<static>> }
											class PlacePlant { <<Use Case>> }
												class RetrievePlants { <<Use Case>> }
													class MyceliumQueryService { <<Service>> }

														PlantMapper ..> Plant : creates/uses
														PlantMapper ..> PlantDto : creates/uses
														PlantMapper ..> HyphaeSerializationService : uses
														GardenMapper ..> PlantMapper : uses
														PlacePlant ..> PlantMapper : uses (IntoPlant)
														RetrievePlants ..> PlantMapper : uses (IntoDto)
														MyceliumQueryService ..> PlantMapper : uses (IntoDto)
					</div>
					<aside class="notes">
						Der `PlantMapper` ist eine statische Klasse, die Methoden zur Konvertierung zwischen
						`Plant`-Dom√§nenobjekten und `PlantDto`-Objekten bereitstellt. Dieses Muster wird von Use Cases
						(<code>PlacePlant</code>, <code>RetrievePlants</code>) und Services
						(<code>MyceliumQueryService</code>) genutzt, um Daten zwischen Schichten zu bewegen, ohne dass
						die Dom√§nenobjekte Kenntnis von den DTOs haben m√ºssen. Der `GardenMapper` nutzt intern ebenfalls
						den `PlantMapper`.
					</aside>
				</section>
				<section>
					<h3>Result Pattern: <code>Result&lt;TSuccess, TError&gt;</code> - Einleitung</h3>
					<p>Das <code>Result&lt;TSuccess, TError&gt;</code>-Muster wird f√ºr eine explizite Fehlerbehandlung
						in der Anwendungsschicht eingesetzt. Anstatt Ausnahmen f√ºr erwartbare Fehler zu werfen, geben
						Methoden ein <code>Result</code>-Objekt zur√ºck, das entweder einen Erfolgswert
						(<code>TSuccess</code>) oder ein Fehlerobjekt (<code>TError</code>) enth√§lt. Dies macht den
						Kontrollfluss klarer und zwingt den Aufrufer, beide F√§lle zu behandeln.</p>
				</section>
				<section>
					<h3>Result Pattern: <code>Result&lt;TSuccess, TError&gt;</code></h3>
					<div class="mermaid">
						classDiagram
						class Result~TSuccess, TErrorEnum~ {
						#_value: TSuccess?
						#_error: ErrorResult~TErrorEnum~?
						+IsSuccess: bool
						+Value: TSuccess
						+Error: ErrorResult~TErrorEnum~
						+Ok(value) Result~TSuccess, TErrorEnum~$
						+Fail(error) Result~TSuccess, TErrorEnum~$
						+Match~TResult~(onSuccess, onFailure) TResult
						}
						note for Result "Generic record for operation outcomes"
						class ErrorResult~TErrorEnum~ {
						<<record>>
							+Code: TErrorEnum
							+Message: string
							+Target: string?
							}
							class ResultFactory {
							<<static>>
								+Ok~TSuccess, TErrorEnum~(value) Result
								+Fail~TSuccess, TErrorEnum~(code, message, ?target) Result
								}
								Result~TSuccess, TErrorEnum~ o-- "1" ErrorResult~TErrorEnum~ : contains (on failure)
								ResultFactory ..> Result~TSuccess, TErrorEnum~ : creates

								%% --- Example Usage ---
								class PlacePlant {
								<<Use Case>>
									+IntoGarden(...) Task~Result~PlacePlantSuccess, PlacePlantErrors~~
									}
									class PlacePlantSuccess { <<record>> }
										class PlacePlantErrors { <<enumeration>> PlantAlreadyExists, GardenNotFound }
											PlacePlant ..> Result~PlacePlantSuccess, PlacePlantErrors~ : returns
											Result~PlacePlantSuccess, PlacePlantErrors~ o-- "1" PlacePlantSuccess :
											contains (on success)
											ErrorResult~TErrorEnum~ ..> PlacePlantErrors : uses (as TErrorEnum)
					</div>
					<aside class="notes">
						Das `Result`-Pattern kapselt das Ergebnis einer Operation. Es kann entweder einen Erfolgswert
						vom Typ `TSuccess` oder ein `ErrorResult` (mit einem Enum-Code `TErrorEnum` und einer Nachricht)
						enthalten. Use Cases wie `PlacePlant` geben `Task<Result<...>>` zur√ºck. Dies erm√∂glicht eine
							funktionale Fehlerbehandlung ohne Exceptions f√ºr erwartete Fehlschl√§ge und macht den Erfolg
							oder Misserfolg einer Operation explizit. Eine `ResultFactory` hilft bei der Erstellung von
							`Result`-Instanzen.
					</aside>
				</section>
			</section>

			<section>
				<h2>Vielen Dank!</h2>
				<p>Weitere Fragen?</p>
			</section>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@11.4.1/plugin/mermaid/mermaid.js"></script>

	<script>
		// More info about initialization & config:
		// - https://revealjs.com/config/
		// - https://revealjs.com/api/
		Reveal.initialize({
			hash: true,
			controls: true,
			progress: true,
			center: true,
			slideNumber: 'c/t',
			// Standard navigation (allows vertical slides)
			navigationMode: 'default',

			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid]
		});
	</script>
</body>

</html>