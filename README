# Virtual Arboretum Protokoll

---
## â›² **EinfÃ¼hrung** 

---
**Was** macht die Applikation?
- Pflanzen (Daten aller Art) in GÃ¤rten einlagern und sie untereinander mit *Hyphen* verknÃ¼pfen.
- Pflanzen nach Garten > Pflanze hierarchisch ausgeben.
- Pflanzen Ã¼ber Mycelium-Query selektieren und ebenfalls in Garden > Pflanzen Hierarchie ausgeben.
---
**Wie** soll sie funktionieren?
- Ãœber ein CLI wird mit der Applikation interagiert.
	- *Aktuell jedoch nur Ã¼ber Tests der Use-Cases.*
---
Welches Problem lÃ¶st sie/welchen Zweck hat sie?
- LÃ¤sst eine lokale Verzeichnisstruktur frei wachsen und erfasst attributbasierte ZusammenhÃ¤nge, wodurch neben klassischer Hierarchie **natÃ¼rliche Verbindungen** entstehen kÃ¶nnen.
---
Welches Problem lÃ¶st sie/welchen Zweck hat sie?
- *Limitierungen in Datei-Namen bzgl. der LÃ¤nge (255 Byte) sollen mithilfe strukturierter Assoziation Ã¼ber symbolic links mit verschiedenen Hyphae (Attributen) assoziiert werden.* 
- *All das, so nah wie mÃ¶glich am Dateisystem, damit keine groÃŸen AbhÃ¤ngigkeiten durch individuelle Formate entstehe, wo diese gar nicht benÃ¶tigt werden (wie das mit anderen Tagging-Enginges hÃ¤ufig der Fall ist).*
---
**Wie** startet man die Applikation?
- Aktuell leider nur Ã¼ber Tests von Use-Cases, da Ã¤uÃŸerste PrÃ¤sentations-Schicht noch nicht angeschlossen ist.
	 - Ziel ist jedoch Ã¼ber...
		1. CLI mittels direkter, lokaler Interaktion in Terminal.
		2. REST API/WebUI zum Einlagern von Webseiten.
		3. *Dateisystem-Watcher wie in git registrieren und Ã„nderungen einlagern.*
---
Was fÃ¼r **Voraussetzungen** werden benÃ¶tigt?
 - Keine, da Single Executable VerÃ¶ffentlichung mÃ¶glich.
 - *Idealerweise ist .NET Runtime dennoch vorhanden, da sonst dessen Binaries ausgeteilt werden mÃ¼ssen.*
- Kann bei Bedarf in Container betrieben werden.
---
 **Demonstration zweier Usecases**
- `PlacePlant`: Pflanzen mit assoziierenden Hyphae einlagern.
- `RetrievePlant`: Pflanzen nach Hyphae Query selektieren und auswerten.
---
### ğŸ—ºï¸ Technischer Ãœberblick 

---
- **C# .NET Core 9** (aktuellste LTS)
	- *PrimÃ¤r aus Eigeninteresse heraus, um die Sprache kennenzulerenen.*
- AusschlieÃŸlich mit **System-Bibliotheken**, da Projektvorgabe.
- **LINQ** (aus .NET Core) fÃ¼r verschiedene Daten-Transformations-Aufgaben 
	- *Ã„quivalent zu Stream API ab Java 8.*
- **MSTest**, Testing-Framework zum DurchfÃ¼hren automatischer (Unit-)Tests.
- **SonarQube** und dessen **Erweiterung in VS** *fÃ¼r tiefere Einblicke in die Code-QualitÃ¤t* .

---
## ğŸ§¹ **Clean Architecture**
---
Was ist Clean Architecture?  
- Eine saubere Architektur zeichnet sich durch saubere Grenzen zwischen ihren Ebenen aus.
- Eine saubere Grenze von der..
	- ..DomÃ¤ne gegenÃ¼ber der Anwendung.
	- ..Anwendung gegenÃ¼ber Anwendenden.
	- ..*Anwendung gegenÃ¼ber Angewendetem.*
- *Diese Grenzen dÃ¼rfen von auÃŸen nach innen relativ frei Ã¼berschritten werden und von innen nach auÃŸen nur Ã¼ber VertrÃ¤ge.*

---
<img src="Studere ğŸ“/6. Semester ğŸ‰/ğŸ—ï¸ Advanced Software Engineering/{01} Programmentwurf/{01} Project/IMG_0562.jpg" alt="Clean Architecture" width="70%">

---
### **Analyse der Dependency Rule**
---
 **âœ… Dependency Rule**: AbhÃ¤ngigkeiten dÃ¼rfen nur i.R. innerer Schichten zeigen.
- `PlacePlant` UseCase, verwendet richtig DTOs aus seiner Schicht und lÃ¤sst diese Ã¼ber `PlantMapper` auf Typen aus DomÃ¤ne abbilden und vice versa.
---
âš ï¸ **Dependency Rule verletzt**: AbhÃ¤ngigkeit zeigt nach auÃŸen: `CellType`.
- Verwendet (als einziges) in DomÃ¤nen-Modell den `Console.Error.WriteLine`,
  um zu signalisieren, dass ein MediaType nicht offiziell unterstÃ¼tzt wird.
- *LÃ¶sung bspw. ein Logging-Singleton, der  Fehler Ã¼ber ein Repository in Log-Aggregator o. Datei schreibt || Verlargerung in Applikations-Schicht mit dortigem `Result<>`.*
---
### ğŸ” Analyse der Schichten
---
**EntitÃ¤t** in DomÃ¤ne: `Plant`
- Identifiziert  Zusammenschluss aus `cells` und ordnet diese zwei Abstraktions-Mustern zu: 
	1. Hierarchischen Modell Ã¼ber den `.Name` HyphaStrain 
	2. Attribute-basiert Ã¼ber eine Vielzahl an `AssociatedHyphae` -Strains.
- Zusammenschluss aus verschiedenen Werteobjekten und anderen EntitÃ¤ten und EigenstÃ¤ndigkeit Ã¼ber Lebenszyklus, deshalb handelt es sich um eine EntitÃ¤t.
---
- **UseCase** in : `PlacePlant`
	- Bietet verschiedene Methoden, die `PlantDto` und `GardenDto`  verorten und ggf. Mycchorization durchfÃ¼hren. 
	- Ist in Clean-Architecture eindeutig Teil der Applikations-Schicht und von NÃ¶ten um "sicher" mit internas zu interagieren und diese zu persistieren.
---
## ğŸª¨ **SOLID**
---
### ğŸ” Analyse **Single Responsibility Principle**
---
**positive Beispiel-Klasse** fÃ¼r SRP: `Fingerprint`.
- Hat als Werteobjekt nur eine Aufgabe: GUID v7 wrappen.
- Und zusÃ¤tzlich eine Methode anzubieten, die Unix-Zeitstempel fÃ¼r Chronologie zugÃ¤nglich macht.
---
**negative Beispiel-Klasse** fÃ¼r SRP: `Mycelium` 
- HÃ¤lt Hyphal-Plexus (Hyphen-Netzwerk), sowie Assoziationen zwischen Strains und Plants, sowie Strains und Gardens und ist "Grammatik" der Hyphae-Sprache.
- Idealerweise wird Verantwortung weiter ausgelagert
	- In lokale Plexus innerhalb von `Garden`-Instanzen.
	- In eine `MyceliumAssociations`-Instanz, die Assoziationen Ã¼bernehmen. 

---
### ğŸ” Analyse **Open Closed Principle**
---
âœ… **positive Beispiel** fÃ¼r OCP: Die Basis-Klasse `Hypha`.
- Die fÃ¼r sich selbst als interne "Erweiterung" eines HyphaStrains verwendet werden kann. 
- Spezielle Implementierungen wie der `HyphaApex`, ein einfacher textuelles Ende eines Strains oder eine `DecimalHypha` erweitern entsprechend die Basis-Klasse.
---

```mermaid
classDiagram
Â  Â  %%! Basisklasse fÃ¼r alle Hypha-Typen im DomÃ¤nenmodell.
Â  Â  class Hypha {
Â  Â  Â  Â  +HyphaKey Key
Â  Â  Â  Â  +DoesExtend() bool
Â  Â  Â  Â  +NextExtension() Hypha?
Â  Â  Â  Â  +ToString() string
Â  Â  Â  Â  +Equals(object other) bool
Â  Â  Â  Â  +GetHashCode() int
Â  Â  }
  
Â  Â  %%! Spezialisierte Hypha, die wie ein einfacher Tag funktioniert.
Â  Â  %%! Der 'Value' der Basisklasse ist hier gleich dem 'Key'.
Â  Â  class HyphaApex {
Â  Â  Â  Â  Â +ToString() string
Â  Â  }
  
Â  Â  %%! Spezialisierte Hypha, die einen Dezimalwert reprÃ¤sentiert.
Â  Â  %%! Der Dezimalwert wird im 'Value' der Basisklasse gespeichert.
Â  Â  class DecimalHypha {
Â  Â  Â  Â  +AsDecimal() Decimal
Â  Â  }
  
Â  Â  %%! Stellt den SchlÃ¼ssel (Namensteil) einer Hypha dar.
Â  Â  class HyphaKey {
Â  Â  Â  +string Value
Â  Â  Â  +ToString() string
Â  Â  }


Â  Â  %%! Vererbungsbeziehungen von der Basisklasse Hypha.
Â  Â  Hypha <|-- HyphaApex
Â  Â  Hypha <|-- DecimalHypha

  
Â  Â  %%! Assoziation: Jede Hypha hat genau einen HyphaKey.
Â  Â  Hypha "1" *-- "1" HyphaKey : hat
```
---

âš ï¸ **negatives Beispiel** fÃ¼r OCP: `ParseHyphaType(hyphaKey, hyphaValue)`.
- OCP wird verletzt, weil Parsing-Vorgang hier ohne Compiler-Warnung vorgenommen werden mus.
- Werden nun `DateTimeHypha` oder `IpAddressHypa` hinzugefÃ¼gt, mÃ¼sste auch daran gedacht werden, die Serialisierung hier vorzunehmen.
- Idealerweise wird bei Erweiterung gefordert, dass `IParsable` o.Ã¤. implementiert wird, das von `HyphaeSerializationService` Ã¼ber ein Strategie-Pattern angesprochen wird.

---

```mermaid
classDiagram
Â  Â  direction TB

Â  Â  class HyphaeSerializationService {
Â  Â  Â  Â  +ParseHyphaType(string hyphaKey, string hyphaValue) Hypha
Â  Â  Â  Â  ...
Â  Â  }
  
Â  Â  %%! Basis-Hypha (oder Interface)
Â  Â  class Hypha {
Â  Â  Â  Â  <<abstract>>
Â  Â  Â  Â  +HyphaKey Key
Â  Â  Â  Â  +object Value
Â  Â  }
  
Â  Â  %%! Bestehende, spezifische Hypha-Implementierungen
Â  Â  class DecimalHypha
Â  Â  class HyphaApex
  
Â  Â  %%! Neuer, hinzuzufÃ¼gender Hypha-Typ
Â  Â  class DateTimeHypha {
Â  Â  Â  Â  +DateTime AsDateTime()
Â  Â  }
  
Â  Â  %%! Vererbungsbeziehungen
Â  Â  Hypha <|-- DecimalHypha
Â  Â  Hypha <|-- HyphaApex
Â  Â  Hypha <|-- DateTimeHypha
  
Â  Â  %%! AbhÃ¤ngigkeiten: Service erstellt/verwendet die Hypha-Typen
Â  Â  HyphaeSerializationService ..> DecimalHypha : creates/uses
Â  Â  HyphaeSerializationService ..> HyphaApex : creates/uses
Â  Â  HyphaeSerializationService ..> DateTimeHypha : creates/uses (nach Modifikation!)
```

---

### ğŸ” Analyse **Interface Segragation**- und **Dependency Inversion**-Prinzipien

---

**Positive Beispiel-Klassen fÃ¼r Dependency Inversion**: Die beiden Use-Cases `PlacePlant` und `RetrievePlant`. 
- Beide verwenden im Sinne der Clean Architecture ausschlieÃŸlich `IRepository` Interfaces zum Ein- und Auslagern verschiedener EntitÃ¤ten verwenden.
- *NÃ¤chstes UML zeigt  Relation auf.*

---

**negatives Beispiel fÃ¼r Interface Segregation** kann `IRepository<T>` sein.
 - Bietet wom. zu viele Varianten zum Abfragen an.
 - Bei Erweiterung um bspw. das `ICellRepository` fÃ¼hrt das zu Uneindeutigkeiten, wenn bspw. die `OrganellLocation` von dem Repository dennoch als `GetByPrimaryHyphaeAsync` angesprochen wird.
	- *Repository-Zugriffe aufgesplittet und ggf. sogar soweit zerlegt werden, dass sie nach Lese-/Schreib-Zugriffen abgegrenzt sind.*
	
---

```mermaid
classDiagram
Â  Â  %% Base Repository Interface
Â  Â  class IRepository~T~ {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  %% Definiert allgemeine Repository-Operationen
Â  Â  Â  Â  +GetByFingerprintAsync(Fingerprint id) Task~T?~
Â  Â  Â  Â  +GetByPrimaryHyphaeAsync(HyphaeStrain strain) Task~T?~
Â  Â  Â  Â  +AddAsync(T candidate) Task
Â  Â  Â  Â  +UpdateAsync(T candidate) Task
Â  Â  }

Â  Â  %% Specific Repository Interfaces
Â  Â  class IArboretumRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  %% Verwaltet das Arboretum-Aggregat
Â  Â  Â  Â  +Open() Arboretum
Â  Â  Â  Â  +Close() Boolean
Â  Â  }

Â  Â  class ICellRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  %% Erbt von IRepository<Cell>
Â  Â  }
Â  Â  
Â  Â  class IGardenRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  %% Erbt von IRepository<Garden>
Â  Â  }
Â  Â  
Â  Â  %% class IMyceliumRepository {
Â  Â  %% Â  Â  <<interface>>
Â  Â  %% Â  Â  %% Erbt von IRepository<Mycelium>
Â  Â  %% Â  Â  %% Hinweis: Keine InMemory-Implementierung in den bereitgestellten Dateien gefunden
Â  Â  %% }

Â  Â  class IPlantRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  %% Erbt von IRepository<Plant>
Â  Â  }

Â  Â  %% Interface Inheritance/Realization from IRepository<T>
Â  Â  IRepository~Cell~ <|-- ICellRepository
Â  Â  IRepository~Garden~ <|-- IGardenRepository
Â  Â  %% IRepository~Mycelium~ <|-- IMyceliumRepository
Â  Â  IRepository~Plant~ <|-- IPlantRepository
  
Â  Â  %% InMemory Implementations
Â  Â  class InMemoryArboretumRepository {
Â  Â  Â  Â  %% Implementiert IArboretumRepository
Â  Â  }
Â  Â  InMemoryArboretumRepository ..|> IArboretumRepository

Â  Â  class InMemoryCellRepository {
Â  Â  Â  Â  %% Implementiert ICellRepository
Â  Â  }
Â  Â  
Â  Â  InMemoryCellRepository ..|> ICellRepository

Â  Â  class InMemoryGardenRepository {
Â  Â  Â  Â  %% Implementiert IGardenRepository
Â  Â  }
Â  Â  InMemoryGardenRepository ..|> IGardenRepository


Â  Â  class InMemoryPlantRepository {
Â  Â  Â  Â  %% Implementiert IPlantRepository
Â  Â  }

Â  Â  InMemoryPlantRepository ..|> IPlantRepository  

Â  Â  %% Use Cases and Services
Â  Â  class PlacePlant {
Â  Â  Â  Â  %% Use Case zum Platzieren einer Pflanze
Â  Â  }

Â  Â  class RetrievePlants {
Â  Â  Â  Â  %% Use Case zum Abrufen von Pflanzen
Â  Â  }
Â  Â  class MyceliumQueryService {
Â  Â  Â  Â  %% Service zur Abfrage des Myzeliums, unterstÃ¼tzt RetrievePlants
Â  Â  }


Â  Â  %% Dependencies from Use Cases/Services to Repository Interfaces
Â  Â  %% Zeigt, welche Use Cases/Services welche Repository-Schnittstellen verwenden
Â  Â  PlacePlant --> IArboretumRepository
Â  Â  PlacePlant --> IGardenRepository
Â  Â  PlacePlant --> IPlantRepository


Â  Â  RetrievePlants --> IArboretumRepository
Â  Â  RetrievePlants --> IPlantRepository

Â  Â  MyceliumQueryService --> IArboretumRepository
Â  Â  MyceliumQueryService --> IPlantRepository
```

---
## **Weitere Prinzipien**

---

Was sind **General Responsibility Assignment Software Patterns**?
- Ein Regelwerk, dass die **Wartbarkeit**, **Wiederverwendbarkeit** und **VerstÃ¤ndlichkeit** sichert, indem eine **geringe Kopplung** Klassen mÃ¶glichst unabhÃ¤ngig voneinander macht und eine **hohe KohÃ¤sion** die Verantwortung einer Klasse fokussiert.

---
### ğŸ” Analyse **GRASP**: **Geringe Kopplung**

---

`GardenMapper` lÃ¶st die Kopplung hin zur PrÃ¤sentations-Schicht.
 - `Garden`-Instanzen aus und zu DTOs gewandelt werden, anstatt direkt `IParsable` auf einem `Garden`-DomÃ¤nenobjekt aufzusatteln. 
 - Statische `GardenMapper` Methoden werden nur von Use-Cases, Services und der Infrastruktur-Schicht in `InMemoryGardenRepository` verwendet und beschreiben beiden Konvertierungsrichtungen: `IntoDto(Garden)` und `IntoGarden(GardenDto)`.

---

### ğŸ” Analyse **GRASP: Polymorphismus** 

---

**positives Beispiel** fÃ¼r Polymorphismus: Die `IRepository<>` Interfaces,
  - die zunÃ¤chst gemeinsame Signaturen verwenden und auf spezielle Interfaces fÃ¼r konkrete DomÃ¤nen-Modelle abbilden
  - um schlieÃŸlich in der Infrastruktur-Schicht von `InMemory...Repository` implementiert zu werden.

---
### ğŸ” **DRY** 
---
- `HyphaHierarchy`
	- **War**: Einfach HyphaKey und finalen Value als String in `ImmutableArray<>` aggregieren.
	- **Ist Nun:** Erst gesammte Hypha flach machen, dann HyphaKey extrahieren, weil Aggregation ganzer Hyphae in HyphaeStrain gebraucht ist.
	- Commit: 69467663fb3a2f2bcfbfa8c4351220be6ebf8ce7
---
**vorher**:
```csharp
public static ImmutableArray<HyphaKey> Aggregate(Hypha root) {
Â  Â  return [.. AggregateSubHyphae(root, 1).Item1];
}

private static (HyphaKey[], ushort) AggregateSubHyphae(
Hypha label, ushort depth = 0
){
Â  Â  if (label.DoesExtend()) {
 Â     Â  var (list, index) = AggregateSubHyphae(
Â  Â  Â  Â  Â  Â  label.NextExtension()!,
Â  Â  Â  Â  Â  Â  ++depth);
    Â  Â  list[index] = label.Key;
Â  Â  Â  Â  return (list, --index);
Â  Â  }
	// recursion basis.
Â  Â  HyphaKey[] aggregate = new HyphaKey[depth];
Â  Â  depth -= 1;
Â  Â  aggregate[depth] = label.Key;
Â  Â  depth -= 1;
Â  Â  return (aggregate, depth);
}

// ..Dasselbe fÃ¼r vollstÃ¤ndige Hypha..
```

---

**nachher**:
```csharp
private static (Hypha[], ushort) AggregateSubHyphae(Hypha hypha, ushort depth = 0) {
Â  Â  if (hypha.DoesExtend()) {
Â  Â  Â  Â  var (list, index) = AggregateSubHyphae(
Â  Â  Â  Â  Â  Â  hypha.NextExtension()!,
Â  Â  Â  Â  Â  Â  ++depth
Â  Â  Â  Â  );
Â  Â  Â  Â  list[index] = hypha;
Â  Â  Â  Â  return (list, --index);
Â  Â  }
Â  Â  // recursion basis.
Â  Â  Hypha[] aggregate = new Hypha[depth];
Â  Â  depth -= 1;
Â  Â  aggregate[depth] = hypha;
Â  Â  depth -= 1;
Â  Â  return (aggregate, depth);
}

public static ImmutableArray<Hypha> AggregateHyphae(Hypha root) {
Â  Â  return [.. AggregateSubHyphae(root, 1).Item1];
}

public static ImmutableArray<HyphaKey> AggregateHyphaeKeys(Hypha root) {
Â  Â  var aggregatedHypha = AggregateHyphae(root);
Â  Â  var hyphaKeys = new List<HyphaKey>(aggregatedHypha.Length);
Â  Â  foreach (var hypha in aggregatedHypha) {
Â  Â  Â  Â  hyphaKeys.Add(hypha.Key);
Â  Â  }
Â  Â  return [..hyphaKeys];
}
```
*Achtung, Code-Duplikation nicht direkt commitet! Dennoch vorher/nacher Sicht mÃ¶glich.* 

---
## **Unit Tests** 

---
### ATRIP
---

- ATRIP: **Automatic** wird mit dem Einsatz des MSTest-Frameworks.
- ATRIP: **Thorough** steht fÃ¼r eine hohe Code-Coverage, die nur bedingt gegeben ist (~40% in 44 verschiedenen Tests). 
	- Alle komplexeren Algorithmen relativ ausfÃ¼hrlich aund vereinzelt data-driven getestet.
	- *Bei Abstraktionen muss nicht getestet werden.*

---

- ATRIP: **Professional**
	- Deskriptive Test-Methoden-Namen nach C# Best-Practices 
		- *zumindest aktuellere nach Name_Zustand_Verhalten*.
	- Datengetriebenes Testen.
	- Strikt nach **AAA** aufgebaut.
	- Schnelle und parallelisierbare Tests.

---
### ğŸ­ **Fakes** und Mocks

---
Fake Factories, die anders als Mocks keine Evaluation und lediglich Scuffholding anbieten,
um In-Memory-Repositories fÃ¼r jeden Test-Kontext individuell zu instanziieren.
`FakeGardenFactory`, `FakePlantFactory`.
 
---
 
 *Factory ist aktuell nicht zwingend angebrachte Bezeichnung, da nur zwischengeschaltene Helper hin zu InMemoryRepos, kÃ¶nnen i.Zkt. allerdings weitere Initialisierungsarten anbieten.*

---
### ### 1. `TestFingerprint.TestFingerprint` `TimestampExtraction()`
- **Zweck:** Validiert Value Object `Fingerprint`.
- **Testet:** Korrekte Extraktion des Erstellungszeitstempels aus einer GUID v7.

---

```csharp
var timestamps = new[]
{
    DateTimeOffset.FromUnixTimeSeconds(987709362),
    DateTimeOffset.FromUnixTimeSeconds(1615676400),
    GetRandomDateTimeOffset()
};

var fingerprints = WrapFingerprints(WrapGuids(timestamps));

var deserializedDateTime = new List<DateTimeOffset>(timestamps.Length);

foreach (var fingerprint in fingerprints)
{
    deserializedDateTime.Add(fingerprint.GetCreationDateTime());
}

for (int i = 0; i < fingerprints.Length; i++)
{
	Assert.AreEqual(timestamps[i], deserializedDateTime[i]);
}
```

---
### 2. `TestHyphaeHierarchy.ShouldResolve` `TertiaryHyphaeHierarchy()`
- **Zweck:** Validiert Domain Service `HyphaeHierarchy`.
- **Testet:** Korrekte Umwandlung einer 3-stufigen `Hypha`-Hierarchie in String-Form.

---

```csharp
var delimiter = HyphaKey.ExtensionDelimiter;
var hyphae = BuildHyphaeOfThree();

var serializedHierarchy = HyphaeHierarchy.AsString(hyphae);

Assert.AreEqual(
    $"Primary{delimiter}Secondary{delimiter}Tertiary",
    serializedHierarchy
    );
```

---
### 3. `TestHyphaSerializer.TestSerializationCycle` `OfHyphaeHierarchyWithValue()`
- **Zweck:** Validiert Application Service `HyphaeSerializationService`.
- **Testet:** Korrekten Roundtrip (Serialisierung -> Deserialisierung -> Serialisierung) fÃ¼r einen `HyphaeStrain`.

---

```csharp
// Arrange
var delimiter = HyphaKey.ExtensionDelimiter;
var serializedHyphae = $"{HyphaKey.StartMarker}keyA{delimiter}keyB{delimiter}value";

// Act
var hyphae = HyphaeSerializationService.Deserialize(serializedHyphae).First();
var newSerializedHyphae = HyphaeSerializationService.Serialize(hyphae);

// Assert
Assert.IsNotNull(hyphae);
Assert.AreEqual(serializedHyphae, newSerializedHyphae);
```

---
### 4. `PlacePlantTest.IntoGarden` `_ValidPlant_AssociatesWithMycelium()`
- **Zweck:** Validiert Use Case `PlacePlant` (Erfolgsfall + Seiteneffekt).
- **Testet:** Korrektes Platzieren einer `Plant` im `Garden` UND die anschlieÃŸende, korrekte Verbindung mit dem `Mycelium`.

---

```csharp
// # Arrange
var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");

// Set up the repositories
var gardenRepo = new InMemoryGardenRepository([testGarden]);
var arboretumRepo = new InMemoryArboretumRepository([testGarden]);
var plantRepo = new InMemoryPlantRepository();

// Create Test Plant
var testPlant = FakePlantFactory.CreateTestPlant(
    "TestPlant",
    "#this-strain-should-absolutely-be-associated" +
    "#this-strain-should-be-associated-as-well", null, null);
var testPlantDto = PlantMapper.IntoDto(testPlant);

var gardenId = new GardenIdentifierInput(testGarden.UniqueMarker.ToString());

// Create the use case with our in-memory repositories
var placePlantUseCae = new PlacePlant(arboretumRepo, gardenRepo, plantRepo);

// # Act
var result = await placePlantUseCae.IntoGarden(testPlantDto, gardenId);

// # Assert
Assert.IsTrue(result.IsSuccess);
Assert.IsNotNull(result.Value);
Assert.AreEqual("#TestPlant", result.Value.PrimaryPlantHyphae); // Korrigiert gemÃ¤ss Factory-Logik

// Verify mycorrhization via mycelium in arboretum
var arboretum = arboretumRepo.Open();

// Plant be present by itself
Assert.IsTrue(arboretum.Mycelium.ContainsMycorrhization(
    testPlant.Name, testPlant.UniqueMarker
    ));

// Plants hyphae strains should be associated with plant.
Assert.IsTrue(arboretum.Mycelium.ContainsMycorrhizations(
    testPlant.AssociatedHyphae, testPlant.UniqueMarker
    ));
```
---
### 5. `RetrievePlantsTest.GetPlantByFingerprintAsync_ExistingPlant` `_ReturnsSuccessWithPlantInGarden()`
- **Zweck:** Validiert Use Case `RetrievePlants` (Erfolgsfall, Single Item).
- **Testet:** Korrektes Auffinden und ZurÃ¼ckgeben einer einzelnen `Plant` (im Kontext ihres `Garden` DTOs) via `Fingerprint`.

---

```csharp
// Arrange
var plant1 = FakePlantFactory.CreateTestPlant("PlantA", "#HyphaA", 0, 0);
var garden1 = FakeGardenFactory.CreateRawTestGarden("Garden1");
garden1.AddPlant(plant1);

var retrievePlantsUseCase = SetupRepositoriesAndUseCase(
	initialPlants: [plant1],
    initialGardens: [garden1]);

var input = new PlantIdentifierInput(plant1.UniqueMarker.ToString());

// Act
var result = await retrievePlantsUseCase.GetPlantByFingerprintAsync(input);

// Assert
IsTrue(result.IsSuccess);
IsNotNull(result.Value);
AreEqual(1, result.Value.MatchingGardens.Count, "Should find the plant in one garden.");
var gardenDto = result.Value.MatchingGardens[0];
AreEqual(garden1.UniqueMarker.ToString(), gardenDto.UniqueMarker);
AreEqual(1, gardenDto.Plants.Count);
AreEqual(plant1.UniqueMarker.ToString(), gardenDto.Plants[0].UniqueMarker);
```

---
### 6. `RetrievePlantsTest.GetAllAsync_WhenGardensAndPlantsExist` `_ReturnsSuccessWithAllGardensAndPlants()`
- **Zweck:** Validiert Use Case `RetrievePlants` (Erfolgsfall, Multiple Items).
- **Testet:** Korrektes ZurÃ¼ckgeben aller `Gardens` mit ihren jeweiligen `Plants` als DTOs bei einem komplexeren Setup.
---

```csharp
// Arrange: Setup with specific test data
var plant1 = FakePlantFactory.CreateTestPlant("PlantA", "#HyphaA", 0, 0);
var plant2 = FakePlantFactory.CreateTestPlant("PlantB", "#HyphaB", 0, 0);
var garden1 = FakeGardenFactory.CreateRawTestGarden("Garden1");
garden1.AddPlant(plant1); // Add plant to garden
var garden2 = FakeGardenFactory.CreateRawTestGarden("Garden2");
garden2.AddPlant(plant2); // Add plant to garden

    // Important: Repos need the final state of gardens/plants
var retrievePlantsUseCase = SetupRepositoriesAndUseCase(
    initialPlants: [plant1, plant2],
    initialGardens: [garden1, garden2]);

// Act
var result = await retrievePlantsUseCase.GetAllAsync();

// Assert
IsTrue(result.IsSuccess);
IsNotNull(result.Value);
AreEqual(2, result.Value.MatchingGardens.Count, "Should return two gardens.");

var garden1Dto = result.Value.MatchingGardens
    .FirstOrDefault(g => g.PrimaryLocation == garden1.PrimaryLocation.ToString());
IsNotNull(garden1Dto);
AreEqual(1, garden1Dto.Plants.Count);
AreEqual(plant1.Name.ToString(), garden1Dto.Plants[0].PrimaryHyphae);

var garden2Dto = result.Value.MatchingGardens
        .FirstOrDefault(g => g.PrimaryLocation == garden2.PrimaryLocation.ToString());
    IsNotNull(garden2Dto);
    AreEqual(1, garden2Dto.Plants.Count);
    AreEqual(plant2.Name.ToString(), garden2Dto.Plants[0].PrimaryHyphae);
}
```

---

### 7. `PlacePlantTest.IntoGarden` `_PlantAlreadyExists_ReturnsFailure()`
- **Zweck:** Validiert Use Case `PlacePlant` (Fehlerfall, GeschÃ¤ftsregel).
- **Testet:** Korrekte Fehlerbehandlung (via `Result` Pattern), wenn eine `Plant` doppelt hinzugefÃ¼gt werden soll.

---

```csharp
// Arrange
var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");

// Set up the repositories
var gardenRepo = new InMemoryGardenRepository([testGarden]);
var arboretumRepo = new InMemoryArboretumRepository([testGarden]);
var plantRepo = new InMemoryPlantRepository();

// Create Test Plant
var testPlant = FakePlantFactory.CreateTestPlant(
	"TestPlant",
    "#this-strain-should-not-be-associated#neither-this-one", null, null);

var testPlantDto = PlantMapper.IntoDto(testPlant);

var gardenId = new GardenIdentifierInput(testGarden.UniqueMarker.ToString());

// Create the use case with our in-memory repositories
var placePlantUseCae = new PlacePlant(arboretumRepo, gardenRepo, plantRepo);

// Act
var firstResult = await placePlantUseCae
    .IntoGarden(testPlantDto, gardenId);

var secondResult = await placePlantUseCae
    .IntoGarden(testPlantDto, gardenId);

// Assert
Assert.IsTrue(firstResult.IsSuccess);
Assert.IsFalse(secondResult.IsSuccess);
Assert.AreEqual(PlacePlantErrors.PlantAlreadyExists, secondResult.Error.Code);
```

---
### 8. `RetrievePlantsTest.ByPrimaryHyphaeAsync` `_NonExistingPlant_ReturnsFailurePlantNotFound()`
- **Zweck:** Validiert Use Case `RetrievePlants` (Fehlerfall, "Not Found").
- **Testet:** Korrekte Fehlerbehandlung (via `Result` Pattern), wenn eine `Plant` Ã¼ber einen nicht existierenden primÃ¤ren `HyphaeStrain` gesucht wird.

---

```csharp
// Arrange
var retrievePlantsUseCase = SetupRepositoriesAndUseCase();
var input = new HyphaeStrainDto("#NonExistentPlant");

// Act
var result = await retrievePlantsUseCase.ByPrimaryHyphaeAsync(input);

// Assert
IsFalse(result.IsSuccess);
AreEqual(RetrievePlantsError.PlantNotFound, result.Error.Code);
```
---
### 9. `PlacePlantTest.IntoGardenWithoutAdditionalMycorrhization` `_ValidPlant_ReturnsSuccess()`
- **Zweck:** Validiert eine spezielle Variante des `PlacePlant`-Use-Cases.
- **Testet:** Erfolgreiches HinzufÃ¼gen einer `Plant` zu einem `Garden`, wobei explizit _keine_ zusÃ¤tzliche Verbindung zum globalen `Mycelium` (auÃŸer der Garten-Assoziation) hergestellt wird.

---

```csharp
// # Arrange
var testGarden = FakeGardenFactory.CreateRawTestGarden("TestGarden");

// Set up the repositories
var gardenRepo = new InMemoryGardenRepository([testGarden]);
var arboretumRepo = new InMemoryArboretumRepository([testGarden]);
var plantRepo = new InMemoryPlantRepository();

// Create Test Plant
var testPlant = FakePlantFactory.CreateTestPlant(
    "TestPlant",
    "#this-strain-should-not-be-associated#neither-this-one", null, null);

var testPlantDto = PlantMapper.IntoDto(testPlant);

var gardenId = new GardenIdentifierInput(testGarden.UniqueMarker.ToString());

// Create the use case with our in-memory repositories
var placePlantUseCae = new PlacePlant(arboretumRepo, gardenRepo, plantRepo);

// # Act
var result = await placePlantUseCae
    .IntoGardenWithoutAdditionalMycorrhization(testPlantDto, gardenId);

// # Assert
Assert.IsTrue(result.IsSuccess);
var resultPlant = result.Value;
Assert.IsNotNull(resultPlant);

Assert.AreEqual("#TestPlant", resultPlant.PrimaryPlantHyphae); // Korrigiert gemÃ¤ss Factory-Logik
Assert.AreEqual(gardenId.GardenFingerprint, resultPlant.NewGardenFingerprint);

// Nooow, the plant should still hold its hyphae (due to information preservation)
//  => but, the mycelium should not be aware of the plant, just the garden.
var arboretum = arboretumRepo.Open();

// Plant should not be present by itself
Assert.IsFalse(arboretum.Mycelium.ContainsMycorrhization(
    testPlant.Name, testPlant.UniqueMarker
    ));

// Plants hyphae strains should not associate with plant.
Assert.IsFalse(arboretum.Mycelium.ContainsMycorrhizations(
    testPlant.AssociatedHyphae, testPlant.UniqueMarker
    ));
```

---
### 10. `RetrievePlantsTest.ByMyceliumQuery` `_VariousScenarios_ReturnsExpectedResult()`
- **Zweck:** Validiert Use Case `RetrievePlants` (Datengetriebener Test).
- **Testet:** Mehrere Query-Szenarien (AND/OR/NOT) effizient durch eine Methode gegen erwartete Ergebnisse (Erfolg/Fehler, Anzahl Treffer).

---

```csharp
// Arrange
var retrievePlantsUseCase = SetupForMyceliumQueryTests();
var input = new QueryMyceliumInput(testCase.HyphaeQuery);

// Act
var result = await retrievePlantsUseCase.ByMyceliumQuery(input);

// Assert
AreEqual(
	testCase.ExpectedSuccess, result.IsSuccess,
    $"Query '{testCase.HyphaeQuery}' - Success state mismatch.");

if (testCase.ExpectedSuccess)
{
    IsNotNull(result.Value, $"Query '{testCase.HyphaeQuery}' - Value should not be null on success.");
    AreEqual(
	    testCase.ExpectedGardenCount, result.Value.MatchingGardens.Count,
        $"Query '{testCase.HyphaeQuery}' - Garden count mismatch.");

    var totalDistinctPlants = result.Value.MatchingGardens
        .SelectMany(garden => garden.Plants)
        .DistinctBy(plant => plant.UniqueMarker)
        .ToList();

    AreEqual(
	    testCase.ExpectedDistinctPlantCount, totalDistinctPlants.Count,
        $"Query '{testCase.HyphaeQuery}' - Total plant count mismatch.");
        
}
    else
    {
        IsNotNull(result.Error,
            $"Query '{testCase.HyphaeQuery}' - Error object should not be null on failure.");
        AreEqual(testCase.ExpectedErrorCode, result.Error.Code,
            $"Query '{testCase.HyphaeQuery}' - Error code mismatch.");
    }
}
```

---
##  **Domain Driven Design**

---
### Ubiquitous Language

---

- **Arboretum:** Das Gesamtsystem; enthÃ¤lt `Gardens` und das zentrale `Mycelium`.
- **Garden:** (**Aggregate Root**) Ein Container/Namespace fÃ¼r `Plants`; hat `Fingerprint` und `PrimaryLocation` (`HyphaeStrain`). Verwaltet enthaltene `Plants`.

---

- **Plant:** (**Entity**) Die zentrale Informationseinheit (z.B. Datei); hat `Fingerprint`, `Name` (`HyphaeStrain`), `AssociatedHyphae` und besteht aus `Cells`.
- **Cell:** (Value Object/**Entity**) Kleinste Dateneinheit einer `Plant`; verweist via `OrganellLocation` (`HyphaeStrain`) auf Daten; hat `Fingerprint` und `CellType`.

---

- **Mycelium:** (**Aggregate Root**/Domain Service) Das zentrale Beziehungsnetzwerk; verbindet `Plants` (`Mycorrhization`) und `Gardens` (`Association`) Ã¼ber `HyphaeStrains`; ermÃ¶glicht `Queries`.
- **HyphaeStrain:** (**Werteobjekt**) Eine spezifische, unverÃ¤nderliche Sequenz von `Hypha`-Objekten; reprÃ¤sentiert einen vollstÃ¤ndigen Attributpfad oder BeziehungsschlÃ¼ssel; wird fÃ¼r `Name`, `PrimaryLocation`, `OrganellLocation`, `AssociatedHyphae` und im `Mycelium` verwendet.

---

- **Hypha:** (**Werteobjekt**) Atomarer Baustein einer Beziehung/eines Attributs (`HyphaKey` + Wert); kann hierarchisch sein.
- **HyphaApex:** (Werteobjekt) Eine spezielle, atomare `Hypha`, die nur aus einem `HyphaKey` besteht (wie ein Tag).

---

- **HyphaKey:** (**Werteobjekt**) Der reine SchlÃ¼ssel/Bezeichner-Teil einer `Hypha`.
- **Fingerprint:** (**Werteobjekt**) Eindeutiger, zeitbasierter Identifikator (GUID v7) fÃ¼r `Plant`, `Garden`, `Cell`.

---

- **Mycorrhization / Mycorrhizate:** (Domain Verb/Noun) Der Prozess oder Zustand der Verbindung einer `Plant` mit dem `Mycelium` Ã¼ber ihre `HyphaeStrains`.
- **Association:** (Domain Noun) Allgemeiner Begriff fÃ¼r Verbindungen im `Mycelium` (z.B. Garden <-> HyphaeStrain).

---

- **Cultivate / Cross:** (Domain Verbs) Aktionen auf `Plants` zur Erzeugung neuer Versionen oder Kombinationen.
- ***PhenotypedPlant:** (Memento) Ein unverÃ¤nderlicher Schnappschuss des Zustands einer* `Plant`.

---
### **Repositories**

---

Repositories, wie `IPlantRepository` und `IGardenRepository`, werden als Abstraktionsschicht eingesetzt, um die Details des Datenzugriffs (z. B. Speichern, Laden, Aktualisieren von `Plants` oder `Gardens`) von der restlichen Anwendungslogik zu entkoppeln.

---

Die Use Cases und Services (`PlacePlant`, `RetrievePlants`, `MyceliumQueryService`) interagieren ausschlieÃŸlich mit diesen Interfaces und erhalten die konkreten Repository-Implementierungen (aktuell die `InMemory...`-Versionen) 
Ã¼ber Dependency Injection im Konstruktor.

---
## Refactoring

---
### Code Smells

---

**Shotgun Surgery**: Die `HyphaeStrain` Klasse zieht sich wie die Hyphen in der Endanwendung   praktisch Ã¼berall durch die DomÃ¤nen- und Applikations-Schicht. 

Ã„nderung zieht viele FolgeÃ¤nderungen mit sich. Ist bedingt by Design, da im Sinne der Bionik die Hyphe das Ãœbertragungsnetz zwischen Pflanzen aufspannt. Werden jedoch weitere Features, zum NÃ¤hrstoff- oder Informations-Austausch implementiert, so sind spezielle Varianten (Kinder) zu erstellen.

---

**Feature Envy** (& Method-Bloat): Die `GroupPlantsIntoGardens` ist neidisch auf `Garden` und `Plant`. 

Idealerweise kann Beziehung `Plant` -> `Garden` (eben das inverse) implizit bereits in der DomÃ¤ne aufgelÃ¶st werden, wom. direkt in Plant, obwohl das eigentlich nicht die richtige Abstraktion ist.

---
### 1. Refactoring

---

Die `Mycelium` Klasse Ã¼bernimmt vermehrt Aufgaben zur Assoziation und Mycorrhization,
wobei besonders Problem mit Trennbarkeit von Pflanzen und GÃ¤rten auftritt,
da beide mit Fingerprints identifiziert werden.

In diesem Refactoring geht es darum die Eindeutigkeit herzustellen,
da nur `Plant`-Instanzen mycchoriziert werden kÃ¶nnen.
Des Weiteren kÃ¶nnen bislang ungenutzte Methoden gestrichen werden,
was zu einer kompakteren Klasse fÃ¼hrt. 

---

Die API bleibt gleich*, implementierende Klassen mÃ¼ssen nicht angepasst werden.
Lediglich die Erwartungshaltung gegenÃ¼ber einzelnen Methoden hat sich korrigiert,
sodass GetMycchorization(s) nur noch Fingerprints von `Plant`-Instanzen zurÃ¼ckgeben kann,
weil nur diese eingelagert werden kÃ¶nnen.

*Die Idee in eine `MyceliumAssociation` Klasse auszulagern wÃ¤re nicht mit den Refactoring-GrundsÃ¤tzen zu vereinbaren gewesen, da sich die API geÃ¤ndert hÃ¤tte. Dennoch kann das i.Zkt. eine sinnvolle Zerlegung sein.*

---

**Commits** 
 - 6e0dc691ad1cef9ca4cc55f37ae16e91e5426322
 - 92cb4a9b87b2d217cd27e061ab980111ad0f9237

---

**UML vorher**:
```mermaid
classDiagram
Â  Â  %% Core Mycelium Class with Fields
Â  Â  class Mycelium {
Â  Â  Â  Â  - _hyphalPlexus: ConcurrentDictionary~HyphaKey, HashSet HyphaeStrain ~
Â  Â  Â  Â  - _mycorrhizalAssociations: ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint ~
Â  Â  Â  Â  + Mycelium(IList~Hypha~ hyphae, ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint ~ mycorrhizalAssociations)
Â  Â  Â  Â  + Mycelium(IList~HyphaeStrain~ hyphaeStrains, ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint ~ mycorrhizalAssociations)
Â  Â  Â  Â  + Mycelium()
Â  Â  Â  Â  - ExtendWith(IList~HyphaeStrain~ hyphaeStrains) Mycelium
Â  Â  Â  Â  - ExtendWith(HyphaeStrain hyphaeStrain) Mycelium
Â  Â  Â  Â  - ExtendWith(IEnumerable~Hypha~ hyphae) Mycelium
Â  Â  Â  Â  + ExtendWith(Hypha hypha) Mycelium
Â  Â  Â  Â  + Contains(ImmutableArray~Hypha~ flatHyphae) bool
Â  Â  Â  Â  + Contains(Hypha hypha) bool
Â  Â  Â  Â  + Contains(HyphaeStrain hyphae) bool
Â  Â  Â  Â  + AssociateWith(Hypha hypha, Fingerprint association) Mycelium
Â  Â  Â  Â  + AssociateWith(IEnumerable~Hypha~ hyphae, Fingerprint association) Mycelium
Â  Â  Â  Â  + AssociateWith(HyphaeStrain strain, Fingerprint association) Mycelium
Â  Â  Â  Â  + AssociateWith(IEnumerable~HyphaeStrain~ hyphaeStrains, Fingerprint plantUniqueMarker) void
Â  Â  Â  Â  + Mycorrhizate(Plant plant) void
Â  Â  Â  Â  + ContainsMycorrhization(HyphaeStrain hyphae, Fingerprint association) bool
Â  Â  Â  Â  + ContainsMycorrhization(Hypha hyphae, Fingerprint association) bool
Â  Â  Â  Â  + ContainsMycorrhizations(IEnumerable~Hypha~ manyHyphae, Fingerprint association) bool
Â  Â  Â  Â  + ContainsMycorrhizations(IEnumerable~HyphaeStrain~ manyHyphae, Fingerprint association) bool
Â  Â  Â  Â  + GetMycorrhization(HyphaeStrain hyphae) ImmutableList~Fingerprint~
Â  Â  Â  Â  + GetMycorrhizations(IList~HyphaeStrain~ hyphaeStrains) ImmutableDictionary~HyphaeStrain, ImmutableList~Fingerprint~~
Â  Â  Â  Â  + GetAllMycorrhizations() ImmutableDictionary~HyphaeStrain, HashSet~Fingerprint~~
Â  Â  }

Â  Â  %% Classes/Types Mycelium Directly Depends On
Â  Â  class HyphaeStrain { <<Aggregate Root>> }
Â  Â  class HyphaKey { <<Value Object>> }
Â  Â  class Fingerprint { <<Value Object>> }
Â  Â  class Plant { <<Entity>> }
Â  Â  class Garden { <<Aggregate Root>> }


Â  Â  %% Classes/Interfaces that Use or Contain Mycelium
Â  Â  class Arboretum {
Â  Â  Â  <<Aggregate Root>>
Â  Â  Â  + Mycelium Mycelium
Â  Â  Â  + InitializeMyceliumWith(ICollection~Garden~ gardens) void
Â  Â  }
Â  Â  
Â  Â  class MyceliumQueryService {
Â  Â  Â  <<Service>>
Â  Â  Â  - mycelium : Mycelium
Â  Â  Â  + FindAllByHyphaeQueryAsync(QueryMyceliumInput hyphaeQuery) Task~Result~...~~
Â  Â  }
Â  Â  
Â  Â  class PlacePlant {
Â  Â  Â  Â %% Use Case - Indirectly uses Mycelium via Arboretum
Â  Â  }
  
Â  Â  %% Mycelium's Internal Dependencies
Â  Â  Mycelium --> HyphaeStrain : uses
Â  Â  Mycelium --> HyphaKey : uses
Â  Â  Mycelium --> Fingerprint : uses
Â  Â  Mycelium --> Plant : uses in methods
Â  Â  Mycelium --> Garden : uses in methods
  
Â  Â  %% Composition/Usage Relationships
Â  Â  Arboretum "1" *-- "1" Mycelium : contains / owns
Â  Â  MyceliumQueryService --> Arboretum : uses (to get Mycelium)
Â  Â  MyceliumQueryService --> Mycelium : uses methods
  
Â  Â  %% Indirect Usage (Example)
Â  Â  PlacePlant --> Arboretum : uses
```

---

**UML nachher**:
```mermaid
classDiagram
Â  Â  %% Core Mycelium Class with Fields
Â  Â  class Mycelium {
Â  Â  Â  Â  <<Aggregate Root>>
Â  Â  Â  Â  - _hyphalPlexus : ConcurrentDictionary~HyphaKey, HashSet HyphaeStrain~
Â  Â  Â  Â  - _plantMycorrhizations : ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint~
Â  Â  Â  Â  - _gardenAssociations : ConcurrentDictionary~HyphaeStrain, HashSet Fingerprint~
 

Â  Â  Â  Â  + Mycorrhizate(Plant plant) void
Â  Â  Â  Â  + AssociateWithGarden(HyphaeStrain strain, Garden association) Mycelium
Â  Â  Â  Â  + GetMycorrhization(HyphaeStrain hyphae) ImmutableList~Fingerprint~
Â  Â  Â  Â  + GetMycorrhizations(IList~HyphaeStrain~ hyphaeStrains) ImmutableDictionary~HyphaeStrain, ImmutableList Fingerprint ~
Â  Â  Â  Â  + GetAllMycorrhizations() ImmutableDictionary~HyphaeStrain, HashSet Fingerprint ~
Â  Â  Â  Â  + ContainsMycorrhization(HyphaeStrain hyphae, Fingerprint association) bool
Â  Â  }

  Â  %% Classes/Types Mycelium Directly Depends On
Â  Â  class HyphaeStrain { <<Aggregate Root>> }
Â  Â  class HyphaKey { <<Value Object>> }
Â  Â  class Fingerprint { <<Value Object>> }
Â  Â  class Plant { <<Entity>> }
Â  Â  class Garden { <<Aggregate Root>> }
Â  Â  %% Used implicitly via HyphaeStrain

 
Â  Â  %% Classes/Interfaces that Use or Contain Mycelium
  Â  class Arboretum {
Â  Â  Â  <<Aggregate Root>>
Â  Â  Â  + Mycelium : Mycelium
Â  Â  Â  + InitializeMyceliumWith(ICollection~Garden~ gardens) void
Â  Â  }

Â  Â  class MyceliumQueryService {
Â  Â  Â  <<Service>>
Â  Â  Â  - mycelium : Mycelium
Â  Â  Â  + FindAllByHyphaeQueryAsync(QueryMyceliumInput hyphaeQuery) Task~Result~...~~
Â  Â  }

Â  Â  class PlacePlant {
Â  Â  Â  Â %% Use Case - Indirectly uses Mycelium via Arboretum
Â  Â  } 

Â  Â  %% Mycelium's Internal Dependencies
Â  Â  Mycelium --> HyphaeStrain : uses
Â  Â  Mycelium --> HyphaKey : uses
Â  Â  Mycelium --> Fingerprint : uses
Â  Â  Mycelium --> Plant : uses in methods
Â  Â  Mycelium --> Garden : uses in methods

Â  Â  %% Composition/Usage Relationships
Â  Â  Arboretum "1" *-- "1" Mycelium : contains / owns
Â  Â  MyceliumQueryService --> Arboretum : uses (to get Mycelium)
Â  Â  MyceliumQueryService --> Mycelium : uses methods
  
Â  Â  %% Indirect Usage (Example)
Â  Â  PlacePlant --> Arboretum : uses
```

---
### 2. Refactoring

---

`MyceliumQueryService` ist ein Bloater.
Die Idee ist die Aufgaben in einem Interpreter zu teilen und den Service zu vereinfachen. 
DafÃ¼r sollte Bottom-Up zunÃ¤chst das Sprachkonstrukt mit den verschiedenen `Or`, `And` und `Not` AusdrÃ¼cken definiert werden.
Diese sollen schlieÃŸlich in einem `HyphaeQueryParser` zusammengefÃ¼hrt werden
mit dem die aktuelle Sprache beibehalten wird.

---

**UML vorher**:
```mermaid
classDiagram
Â  Â  %% The Service being described
Â  Â  class MyceliumQueryService {
Â  Â  Â  Â  <<Service>>
Â  Â  Â  Â  %% Fields representing dependencies
Â  Â  Â  Â  - _arboretumRepo IArboretumRepository
Â  Â  Â  Â  - _plantRepo IPlantRepository
Â  Â  Â  Â  - mycelium Mycelium %% Instance obtained via _arboretumRepo

Â  Â  Â  Â  #Key Public Methods:
Â  Â  Â  Â  + FindAllByHyphaeQueryAsync(QueryMyceliumInput hyphaeQuery) Task Result~MyceliumQuerySuccess, MyceliumQueryError~
Â  Â  Â  Â  + GroupPlantsIntoGardens(IList~Fingerprint~ plantIdentifyingFingerprints) Task Result~MyceliumQuerySuccess, MyceliumQueryError~
Â  Â  Â  Â  + 
Â  Â  Â  Â  # Private Methods
Â  Â  Â  Â  - FindAllInSingleOrBucket(string orBucket) Task Result~...~
Â  Â  Â  Â  - QueryMyceliumIntersection(plainHyphae, negatedHyphae) Task Result~...~
Â  Â  Â  Â  - QueryMyceliumNegatedAll(IList~HyphaeStrain~ negated) Task Result~...~
Â  Â  Â  Â  - QueryMyceliumMixedIntersection(plainHyphae, negatedHyphae) Task Result~...~
Â  Â  }
  
Â  Â  %% Interfaces the Service Depends On
Â  Â  class IArboretumRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  + Open() Arboretum
Â  Â  }
Â  Â  
Â  Â  class IPlantRepository {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  + GetByFingerprintAsync(Fingerprint id) Task~Plant?~
Â  Â  Â  Â  %% Other IRepository<Plant> methods...
Â  Â  }
  
Â  Â  %% Concrete Implementations of Dependent Interfaces (used in context/DI)
Â  Â  class InMemoryArboretumRepository {
Â  Â  Â  Â  <<Infrastructure>>
Â  Â  }
Â  Â  
Â  Â  class InMemoryPlantRepository {
Â  Â  Â  Â  <<Infrastructure>>
Â  Â  }
  
Â  Â  %% Domain Objects Used/Accessed by the Service
Â  Â  class Arboretum { <<Aggregate Root>> }
Â  Â  class Mycelium { <<Aggregate Root>> }
Â  Â  class Plant { <<Entity>> }
Â  Â  class Garden { <<Aggregate Root>> }
Â  Â  class Fingerprint { <<Value Object>> }
Â  Â  class HyphaeStrain { <<Aggregate Root>> }
Â  Â  Â %% Also acts like a Value Object in comparisons
Â  Â  class HyphaKey { <<Value Object>> }
  
Â  Â  %% DTOs Used by the Service
Â  Â  class QueryMyceliumInput { <<DTO>> }
Â  Â  class MyceliumQuerySuccess { <<DTO>> }
Â  Â  class GardenDto { <<DTO>> }
Â  Â  class PlantDto { <<DTO>> }
Â  Â  class Result~TSuccess, TError~ { <<Utility>> }
Â  Â  %% Generic Result Pattern

Â  Â  %% Other Services/Utilities Used
Â  Â  class PlantMapper { <<Mapper Utility>> }
Â  Â  class HyphaeSerializationService { <<Service>> }

Â  Â  %% Classes that Use MyceliumQueryService
Â  Â  class RetrievePlants { <<Use Case>> }
  
Â  Â  %% --- Relationships ---  
Â  Â  %% Implementation Relationships
Â  Â  InMemoryArboretumRepository ..|> IArboretumRepository
Â  Â  InMemoryPlantRepository ..|> IPlantRepository
  
Â  Â  %% Dependencies OF MyceliumQueryService
Â  Â  MyceliumQueryService --> IArboretumRepository : uses
Â  Â  MyceliumQueryService --> IPlantRepository : uses
Â  Â  MyceliumQueryService --> Arboretum : accesses (via IArboretumRepository)
Â  Â  MyceliumQueryService --> Mycelium : uses methods of (via Arboretum)
Â  Â  MyceliumQueryService --> Plant : accesses (via IPlantRepository)
Â  Â  MyceliumQueryService --> Garden : accesses (via Arboretum/Plant)
Â  Â  MyceliumQueryService --> Fingerprint : uses
Â  Â  MyceliumQueryService --> HyphaeStrain : uses
Â  Â  MyceliumQueryService --> HyphaKey : uses (indirectly via parsing/serialization)
Â  Â  MyceliumQueryService --> QueryMyceliumInput : input parameter
Â  Â  MyceliumQueryService --> MyceliumQuerySuccess : returns in Result
Â  Â  MyceliumQueryService --> GardenDto : constructs for result
Â  Â  MyceliumQueryService --> PlantDto : constructs for result
Â  Â  MyceliumQueryService --> Result~TSuccess, TError~ : returns
Â  Â  MyceliumQueryService --> PlantMapper : uses
Â  Â  MyceliumQueryService --> HyphaeSerializationService : uses

Â  Â  %% Dependencies TO MyceliumQueryService
Â  Â  RetrievePlants --> MyceliumQueryService : uses
```

---

**UML nachher**:
```mermaid
classDiagram
Â  Â  direction LR

Â  Â  class MyceliumQueryService {
Â  Â  Â  Â  -IArboretumRepository _arboretumRepo
Â  Â  Â  Â  -IPlantRepository _plantRepo
Â  Â  Â  Â  
Â  Â  Â  Â  +FindAllByHyphaeQueryAsync(QueryMyceliumInput) Task~Result~MyceliumQuerySuccess, MyceliumQueryError~~
Â  Â  Â  Â  +GroupPlantsIntoGardens(IList~Fingerprint~) Task~Result~MyceliumQuerySuccess, MyceliumQueryError~~
Â  Â  Â  Â  -MapParserErrorToServiceError(MyceliumQueryParserError) MyceliumQueryError
Â  Â  }

Â  Â  class HyphaeQueryParser {
Â  Â  Â  Â  %% Private Konstanten/statische Felder sind konzeptionell Teil der Klasse
Â  Â  Â  Â  -OR_MARKER : char
Â  Â  Â  Â  -NOT_MARKER : char
Â  Â  Â  Â  -HYPHAE_START_MARKER : char
Â  Â  Â  Â  +Parse(string query) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
Â  Â  Â  Â  -ParseAndGroup(sring andGroupString) Result~IHyphaeQueryExpression, MyceliumQueryParserError~
Â  Â  Â  Â  -TokenizeAndGroup(string groupString) List~TermToken~
Â  Â  }
Â  Â  %% Der private Record TermToken innerhalb von HyphaeQueryParser
Â  Â  class TermToken {
Â  Â  Â  Â  <<record>>
Â  Â  Â  Â  +Term : string
Â  Â  Â  Â  +IsNegated : bool
Â  Â  }

  
Â  Â  class MyceliumContext {
Â  Â  Â  Â  +Mycelium Mycelium
Â  Â  }
  
Â  Â  class IHyphaeQueryExpression {
Â  Â  Â  Â  <<interface>>
Â  Â  Â  Â  +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
Â  Â  }
  
Â  Â  class TerminalHyphaeExpression {
Â  Â  Â  Â  -HyphaeStrain _strain
Â  Â  Â  Â  +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
Â  Â  }
  
Â  Â  class AndExpression {
Â  Â  Â  Â  -IHyphaeQueryExpression _left
Â  Â  Â  Â  -IHyphaeQueryExpression _right
Â  Â  Â  Â  +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
Â  Â  }
  
Â  Â  class OrExpression {
Â  Â  Â  Â  -IHyphaeQueryExpression _left
Â  Â  Â  Â  -IHyphaeQueryExpression _right
Â  Â  Â  Â  +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
Â  Â  }
  
Â  Â  class NotExpression {
Â  Â  Â  Â  -IHyphaeQueryExpression _expression
Â  Â  Â  Â  +Interpret(MyceliumContext context) ImmutableList~Fingerprint~
Â  Â  }
  
Â  Â  %% Externe, aber direkt relevante Klassen (nur Namen)
Â  Â  class QueryMyceliumInput
Â  Â  class MyceliumQuerySuccess
Â  Â  class MyceliumQueryError
Â  Â  class MyceliumQueryParserError
Â  Â  class Fingerprint
Â  Â  class Mycelium
Â  Â  class HyphaeStrain
Â  Â  class IArboretumRepository
Â  Â  class IPlantRepository
Â  Â  class HyphaeSerializationService
  
Â  Â  %% Beziehungen
Â  Â  MyceliumQueryService ..> HyphaeQueryParser : uses
Â  Â  MyceliumQueryService ..> MyceliumContext : creates
Â  Â  MyceliumQueryService ..> Mycelium : uses (to create context)
Â  Â  MyceliumQueryService ..> IArboretumRepository : uses
Â  Â  MyceliumQueryService ..> IPlantRepository : uses
Â  Â  MyceliumQueryService ..> QueryMyceliumInput : receives
Â  Â  MyceliumQueryService ..> MyceliumQuerySuccess : returns
Â  Â  MyceliumQueryService ..> MyceliumQueryError : returns
  
Â  Â  HyphaeQueryParser ..> IHyphaeQueryExpression : creates
Â  Â  HyphaeQueryParser ..> TerminalHyphaeExpression : creates
Â  Â  HyphaeQueryParser ..> AndExpression : creates
Â  Â  HyphaeQueryParser ..> OrExpression : creates
Â  Â  HyphaeQueryParser ..> NotExpression : creates
Â  Â  HyphaeQueryParser ..> TermToken : uses (creates instances of private record)
Â  Â  HyphaeQueryParser ..> HyphaeSerializationService : uses
Â  Â  HyphaeQueryParser ..> MyceliumQueryParserError : returns

  
Â  Â  IHyphaeQueryExpression <|.. TerminalHyphaeExpression
Â  Â  IHyphaeQueryExpression <|.. AndExpression
Â  Â  IHyphaeQueryExpression <|.. OrExpression
Â  Â  IHyphaeQueryExpression <|.. NotExpression
  
Â  Â  TerminalHyphaeExpression ..> MyceliumContext : uses
Â  Â  TerminalHyphaeExpression ..> HyphaeStrain : uses
Â  Â  AndExpression ..> MyceliumContext : uses
Â  Â  AndExpression o-- IHyphaeQueryExpression : aggregates (left)
Â  Â  AndExpression o-- IHyphaeQueryExpression : aggregates (right)
Â  Â  OrExpression ..> MyceliumContext : uses
Â  Â  OrExpression o-- IHyphaeQueryExpression : aggregates (left)
Â  Â  OrExpression o-- IHyphaeQueryExpression : aggregates (right)
Â  Â  NotExpression ..> MyceliumContext : uses
Â  Â  NotExpression o-- IHyphaeQueryExpression : aggregates
  
Â  Â  MyceliumContext ..> Mycelium : uses
  
Â  Â  %% Weitere Relationen zu externen Klassen (vereinfacht)
Â  Â  TerminalHyphaeExpression ..> Fingerprint : returns via Interpret
Â  Â  AndExpression ..> Fingerprint : returns via Interpret
Â  Â  OrExpression ..> Fingerprint : returns via Interpret
Â  Â  NotExpression ..> Fingerprint : returns via Interpret
```
*Commit: 4f9b678b2856bfd9ab0e3e3ead60be0a94023712*
*âš ï¸ zwei Tests failen bewusst, die mÃ¶chte ich nicht lÃ¤nger zulassen, da sie vorher sowieso nur leere Ergebnisse geliefert haben.*

---
## **Entwurfsmuster**

`HyphaeBuilder`
```mermaid
classDiagram
Â  Â  class HyphaeBuilder {
Â  Â  Â  Â  -List~HyphaKey~ _hyphaeStrain
Â  Â  Â  Â  -Hypha _root
Â  Â  Â  Â  +HyphaeBuilder(Hypha root, List~HyphaKey~?)
Â  Â  Â  Â  +ExtendBy(HyphaKey) HyphaeBuilder
Â  Â  Â  Â  +ExtendBy(Hypha) HyphaeBuilder
Â  Â  Â  Â  +Build() Hypha
Â  Â  }
Â  Â  class Hypha {
Â  Â  Â  +Key: HyphaKey
Â  Â  Â  +Value: object
Â  Â  Â  +NextExtension() Hypha?
Â  Â  Â  +DoesExtend() bool
Â  Â  }

Â  Â  class HyphaKey {
Â  Â  Â  +Value: string
Â  Â  }

Â  Â  class HyphaeSerializationService {
Â  Â  Â  <<static>> +Deserialize(string) ImmutableList~HyphaeStrain~
Â  Â  Â  <<static>> -ParseHypha(string) HyphaeStrain
Â  Â  Â  <<static>> +Serialize(Hypha) string
Â  Â  }

Â  Â  HyphaeBuilder ..> Hypha : builds
Â  Â  HyphaeBuilder ..> HyphaKey : uses
Â  Â  HyphaeBuilder ..> Hypha : depends on (for root)
Â  Â  HyphaeSerializationService ..> HyphaeBuilder : uses (within ParseHypha)
```


---

`PlantMapper`
*Entspricht dem Data Mapper-Muster aus Martin Fowlers Buch 
"Patterns of Enterprise Application Architecture".*
```mermaid
classDiagram
Â  Â  direction LR

Â  Â  class PlantMapper {
Â  Â  Â  Â  <<static>>
Â  Â  Â  Â  +IntoPlant(PlantDto plantTemplate) Plant
Â  Â  Â  Â  +IntoDto(Plant plant) PlantDto
Â  Â  }

  

Â  Â  class Plant {
Â  Â  Â  Â  <<Domain Entity>>
Â  Â  Â  Â  +Name: HyphaeStrain
Â  Â  Â  Â  +UniqueMarker: Fingerprint
Â  Â  Â  Â  +Cells: ImmutableDictionary<Fingerprint, Cell>
Â  Â  Â  Â  +AssociatedHyphae: ImmutableList<HyphaeStrain>
Â  Â  }

Â  Â  class PlantDto {
Â  Â  Â  Â  <<Data Transfer Object>>
Â  Â  Â  Â  +UniqueMarker: String
Â  Â  Â  Â  +PrimaryHyphae: String
Â  Â  Â  Â  +Cells: IList<CellDto>
Â  Â  Â  Â  +AssociatedHyphae: IList<String>
Â  Â  }


Â  Â  class Cell { }
Â  Â  class CellDto { }
Â  Â  class HyphaeStrain { }
Â  Â  class Fingerprint { }
Â  Â  
Â  Â  class HyphaeSerializationService {
Â  Â  Â  Â  <<static>>
Â  Â  Â  Â  +Serialize(...) string
Â  Â  Â  Â  +Deserialize(...) ImmutableList<HyphaeStrain>
Â  Â  }


Â  Â  class GardenMapper {
Â  Â  Â  Â  <<static>>
Â  Â  Â  Â  +IntoGarden(GardenDto) Garden
Â  Â  Â  Â  +IntoDto(Garden) GardenDto
Â  Â  }

  

Â  Â  class PlacePlant {
Â  Â  Â  Â  <<Use Case>>
Â  Â  Â  Â  +IntoGarden(...) Task<Result<PlacePlantSuccess, PlacePlantErrors>>
Â  Â  }

  

Â  Â  class RetrievePlants {
Â  Â  Â  Â  <<Use Case>>
Â  Â  Â  Â  +GetAllAsync() Task<Result<RetrievePlantsSuccess, RetrievePlantsError>>
Â  Â  }

  

Â  Â  class MyceliumQueryService {
Â  Â  Â  Â  <<Service>>
Â  Â  Â  Â  +GroupPlantsIntoGardens(...) Task<Result<...>>
Â  Â  }


Â  Â  PlantMapper ..> Plant : creates/uses
Â  Â  PlantMapper ..> PlantDto : creates/uses
Â  Â  PlantMapper ..> Cell : uses (indirectly via Plant)
Â  Â  PlantMapper ..> CellDto : uses
Â  Â  PlantMapper ..> HyphaeStrain : uses
Â  Â  PlantMapper ..> Fingerprint : uses
Â  Â  PlantMapper ..> HyphaeSerializationService : uses
Â  Â  GardenMapper ..> PlantMapper : uses
Â  Â  PlacePlant ..> PlantMapper : uses (IntoPlant)
Â  Â  RetrievePlants ..> PlantMapper : uses (IntoDto)
Â  Â  MyceliumQueryService ..> PlantMapper : uses (IntoDto)
```

---

 `Result<TSuccess, TError>`
Eine explizite Fehlerbehandlungsstrategie, eingesetzt in der Anwendungs-Schicht.

```mermaid
classDiagram

Â  Â  class Result~TSuccess, TErrorEnum~ {
Â  Â  Â  Â  #_value: TSuccess?
Â  Â  Â  Â  #_error: ErrorResult~TErrorEnum~?
Â  Â  Â  Â  +IsSuccess: bool
Â  Â  Â  Â  +Value: TSuccess
Â  Â  Â  Â  +Error: ErrorResult~TErrorEnum~
Â  Â  Â  Â  +Ok(value) Result~TSuccess, TErrorEnum~$
Â  Â  Â  Â  +Fail(error) Result~TSuccess, TErrorEnum~$
Â  Â  Â  Â  +Match~TResult~(onSuccess, onFailure) TResult
Â  Â  }

Â  Â  note for Result "Generic record for operation outcomes"

Â  Â  class ErrorResult~TErrorEnum~ {
Â  Â  Â  Â  Â <<record>>
Â  Â  Â  Â  Â +Code: TErrorEnum
Â  Â  Â  Â  Â +Message: string
Â  Â  Â  Â  Â +Target: string?
Â  Â  Â  Â  Â +ErrorResult(TErrorEnum code, string message, string? target)
Â  Â  }

Â  Â  class ResultFactory {
Â  Â  Â  Â  <<static>>
Â  Â  Â  Â  +Ok~TSuccess, TErrorEnum~(value) Result
Â  Â  Â  Â  +Fail~TSuccess, TErrorEnum~(code, message, ?target) Result
Â  Â  Â  Â  +Fail~TSuccess, TErrorEnum~(ErrorResult~TErrorEnum~ error) Result
Â  Â  }
  
Â  Â  %% Core Relationships
Â  Â  Result~TSuccess, TErrorEnum~ o-- "1" ErrorResult~TErrorEnum~ : contains (on failure)
Â  Â  ResultFactory ..> Result~TSuccess, TErrorEnum~ : creates
Â  Â  ResultFactory ..> ErrorResult~TErrorEnum~ : creates/uses

Â  Â  %% --- Example Usage ---
Â  Â  class PlacePlant {
Â  Â  Â  Â  <<Use Case>>
Â  Â  Â  Â  +IntoGarden(...) Task~Result
Â  Â  Â  Â  +IntoGardenWithoutAdditionalMycorrhization(...) Task~Result
Â  Â  }
  
Â  Â  class PlacePlantSuccess {
Â  Â  Â  Â  <<record>>
Â  Â  Â  Â  +PlantFingerprint: string
Â  Â  Â  Â  +NewGardenFingerprint: string
Â  Â  Â  Â  +PrimaryPlantHyphae: string
Â  Â  Â  Â  +HyphaeStrains: ImmutableList~string~
Â  Â  }

Â  Â  class PlacePlantErrors {
Â  Â  Â  Â  <<enumeration>>
Â  Â  Â  Â  PlantAlreadyExists
Â  Â  Â  Â  GardenNotFound
Â  Â  Â  Â  AssociationWithMyceliumFailed
Â  Â  Â  Â  PlantCannotBeConstructed
Â  Â  }

Â  Â  PlacePlant ..> Result~PlacePlantSuccess, PlacePlantErrors~ : returns

Â  Â  %% Specific Result contents and Error association
Â  Â  Result~PlacePlantSuccess, PlacePlantErrors~ o-- "1" PlacePlantSuccess : contains (on success)
Â  Â  ErrorResult~TErrorEnum~ ..> PlacePlantErrors : uses (as TErrorEnum)
```